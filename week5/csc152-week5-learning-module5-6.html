<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="CSC 152 Module 5.6 - PowerShell Remoting and Remote Management for Windows Server">
    <title>Module 5.6: PowerShell Remoting and Remote Management | CSC 152</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #0078d4;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --info-color: #16a085;
            --ps-blue: #012456;
            --light-bg: #ecf0f1;
            --white: #ffffff;
            --text-dark: #2c3e50;
            --text-light: #7f8c8d;
            --border-color: #bdc3c7;
            --code-bg: #012456;
            --code-text: #f8f8f2;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 6px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            background-color: var(--light-bg);
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: var(--white);
            border-radius: 10px;
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, var(--ps-blue), var(--secondary-color));
            color: var(--white);
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .module-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .info-badge {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .content-wrapper {
            display: flex;
            min-height: calc(100vh - 200px);
        }

        .sidebar {
            width: 280px;
            background-color: #f8f9fa;
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: calc(100vh - 200px);
        }

        .sidebar h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .nav-item {
            padding: 12px 15px;
            margin-bottom: 5px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background-color: rgba(0, 120, 212, 0.1);
            border-left-color: var(--secondary-color);
        }

        .nav-item.active {
            background-color: rgba(0, 120, 212, 0.15);
            border-left-color: var(--secondary-color);
            font-weight: 600;
        }

        .nav-item.completed::after {
            content: " ‚úì";
            color: var(--success-color);
            float: right;
        }

        .main-content {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
        }

        .section {
            display: none;
            animation: fadeIn 0.4s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--secondary-color);
        }

        h3 {
            color: var(--secondary-color);
            margin-top: 30px;
            margin-bottom: 15px;
        }

        h4 {
            color: var(--primary-color);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        .definition-box {
            background-color: #e8f4f8;
            border-left: 4px solid var(--info-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .definition-box h4 {
            color: var(--info-color);
            margin-top: 0;
        }

        .example-box {
            background-color: #f0f7ff;
            border-left: 4px solid var(--secondary-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .example-box h4 {
            color: var(--secondary-color);
            margin-top: 0;
        }

        .warning-box {
            background-color: #fff3cd;
            border-left: 4px solid var(--warning-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box h4 {
            color: var(--warning-color);
            margin-top: 0;
        }

        .tip-box {
            background-color: #d4edda;
            border-left: 4px solid var(--success-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .tip-box h4 {
            color: var(--success-color);
            margin-top: 0;
        }

        .security-box {
            background-color: #f8d7da;
            border-left: 4px solid var(--accent-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .security-box h4 {
            color: var(--accent-color);
            margin-top: 0;
        }

        .code-block {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            position: relative;
            white-space: pre;
        }

        .code-block::before {
            content: "PowerShell";
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 0.7em;
            color: #5c9fd8;
            text-transform: uppercase;
            font-weight: bold;
        }

        .inline-code {
            background-color: #e8f4f8;
            color: #0078d4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            font-weight: 600;
        }

        .command-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: var(--shadow);
        }

        .command-table th {
            background-color: var(--secondary-color);
            color: var(--white);
            padding: 12px;
            text-align: left;
        }

        .command-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .command-table tr:hover {
            background-color: var(--light-bg);
        }

        .interactive-exercise {
            background-color: var(--white);
            border: 2px solid var(--secondary-color);
            border-radius: 8px;
            padding: 25px;
            margin: 30px 0;
        }

        .interactive-exercise h3 {
            color: var(--secondary-color);
            margin-top: 0;
        }

        .exercise-question {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }

        .exercise-options {
            margin: 15px 0;
        }

        .exercise-option {
            display: block;
            padding: 12px;
            margin: 8px 0;
            background-color: var(--white);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .exercise-option:hover {
            border-color: var(--secondary-color);
            background-color: #f0f7ff;
        }

        .exercise-option input[type="radio"] {
            margin-right: 10px;
        }

        .check-answer-btn {
            background-color: var(--secondary-color);
            color: var(--white);
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .check-answer-btn:hover {
            background-color: #005a9e;
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            display: none;
        }

        .feedback.correct {
            background-color: #d4edda;
            border: 1px solid var(--success-color);
            color: #155724;
            display: block;
        }

        .feedback.incorrect {
            background-color: #f8d7da;
            border: 1px solid var(--accent-color);
            color: #721c24;
            display: block;
        }

        .progress-container {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .progress-bar-wrapper {
            background-color: var(--light-bg);
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-bar {
            background: linear-gradient(90deg, var(--secondary-color), #5c9fd8);
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-weight: bold;
            font-size: 0.9em;
        }

        .script-output {
            background-color: #012456;
            color: #ffffff;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Consolas', 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            white-space: pre;
        }

        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-card {
            background-color: var(--white);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
        }

        .comparison-card h4 {
            color: var(--secondary-color);
            margin-top: 0;
        }

        .key-takeaways {
            background: linear-gradient(135deg, var(--ps-blue) 0%, var(--secondary-color) 100%);
            color: var(--white);
            padding: 30px;
            border-radius: 8px;
            margin: 30px 0;
        }

        .key-takeaways h3 {
            color: var(--white);
            margin-top: 0;
        }

        .try-it-yourself {
            background-color: #fff9e6;
            border: 2px dashed var(--warning-color);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .try-it-yourself h4 {
            color: var(--warning-color);
            margin-top: 0;
        }

        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid var(--border-color);
        }

        .nav-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .nav-btn.prev {
            background-color: var(--text-light);
            color: var(--white);
        }

        .nav-btn.next {
            background-color: var(--secondary-color);
            color: var(--white);
        }

        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        footer {
            background-color: var(--primary-color);
            color: var(--white);
            text-align: center;
            padding: 20px;
        }

        @media print {
            .sidebar, .navigation-buttons, .interactive-exercise {
                display: none;
            }
            .main-content {
                padding: 20px;
            }
            .section {
                display: block !important;
                page-break-after: always;
            }
        }

        @media (max-width: 968px) {
            .content-wrapper {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }
            .main-content {
                padding: 20px;
            }
            .comparison-table {
                grid-template-columns: 1fr;
            }
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .code-block pre,
        .script-output pre {
            margin: 0;
            padding: 0;
            white-space: pre;
            overflow-x: auto;
        }

        .code-block code,
        .script-output code {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: inherit;
            color: inherit;
            background: none;
            padding: 0;
            white-space: pre;
        }

        .key-takeaways h4 {
            color: #ffffff;
            margin-top: 20px;
            margin-bottom: 8px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        .key-takeaways ul {
            margin-left: 20px;
        }

        .key-takeaways li {
            margin-bottom: 8px;
        }

        .key-takeaways code {
            background-color: rgba(255, 255, 255, 0.15);
            color: #ffffff;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Module 5.6: PowerShell Remoting and Remote Management</h1>
            <div class="module-info">
                <div class="info-badge">üìö CSC 152 - Week 5</div>
                <div class="info-badge">‚è±Ô∏è 90 minutes</div>
                <div class="info-badge">üéØ CSLO 1, Objective 5, 10</div>
                <div class="info-badge">üíª Windows Server</div>
            </div>
        </header>

        <div class="content-wrapper">
            <aside class="sidebar">
                <h3>Module Contents</h3>
                <div class="nav-item active" onclick="showSection('intro')">Introduction to Remoting</div>
                <div class="nav-item" onclick="showSection('winrm-config')">WinRM Configuration</div>
                <div class="nav-item" onclick="showSection('invoke-command')">Invoke-Command</div>
                <div class="nav-item" onclick="showSection('pssession')">PowerShell Sessions</div>
                <div class="nav-item" onclick="showSection('data-transfer')">Data Transfer & Scope</div>
                <div class="nav-item" onclick="showSection('security')">Security & Authentication</div>
                <div class="nav-item" onclick="showSection('best-practices')">Best Practices & Troubleshooting</div>
                <div class="nav-item" onclick="showSection('summary')">Summary</div>

                <div class="progress-container" style="margin-top: 30px;">
                    <h3>Your Progress</h3>
                    <div class="progress-bar-wrapper">
                        <div class="progress-bar" id="moduleProgress">0%</div>
                    </div>
                    <p style="text-align: center; color: var(--text-light); font-size: 0.9em;">
                        <span id="sectionsCompleted">0</span> of 8 sections completed
                    </p>
                </div>
            </aside>

            <main class="main-content">
                <!-- Introduction Section -->
                <section id="intro" class="section active">
                    <h2>Introduction to PowerShell Remoting</h2>
                    
                    <p>Welcome to Module 5.6! This module covers PowerShell Remoting, Microsoft's robust and secure technology for managing Windows Server systems remotely. Building on your PowerShell fundamentals from Module 5.3 and scripting skills from Module 5.4, you'll learn how to execute commands and scripts on remote servers, making you an efficient administrator of distributed Windows environments.</p>

                    <h3>What is PowerShell Remoting?</h3>

                    <div class="definition-box">
                        <h4>üìñ PowerShell Remoting</h4>
                        <p><strong>PowerShell Remoting</strong> is a technology that allows you to run PowerShell commands and scripts on one or more remote computers. It is built on <strong>WS-Management (Web Services for Management)</strong>, which is Microsoft's implementation of the <strong>DMTF (Distributed Management Task Force)</strong> standard, and uses the <strong>WinRM (Windows Remote Management)</strong> service.</p>
                        
                        <p><strong>Key benefits:</strong></p>
                        <ul>
                            <li><strong>Secure:</strong> Uses encrypted communication (HTTPS by default)</li>
                            <li><strong>Object-based:</strong> Remote commands return objects, not just text</li>
                            <li><strong>Scalable:</strong> Manage hundreds of computers simultaneously</li>
                            <li><strong>Consistent:</strong> Use the same cmdlets as local administration</li>
                            <li><strong>Versatile:</strong> Interactive sessions, one-to-many command execution, persistent sessions</li>
                        </ul>
                    </div>

                    <h3>PowerShell Remoting vs. SSH</h3>

                    <div class="comparison-table">
                        <div class="comparison-card">
                            <h4>üêß SSH (Linux)</h4>
                            <ul>
                                <li><strong>Protocol:</strong> SSH Protocol</li>
                                <li><strong>Underlying service:</strong> sshd</li>
                                <li><strong>Default Port:</strong> TCP 22</li>
                                <li><strong>Primary for:</strong> Linux/Unix systems</li>
                                <li><strong>Output:</strong> Text-based streams</li>
                                <li><strong>Authentication:</strong> Password, Key-based</li>
                            </ul>
                        </div>

                        <div class="comparison-card">
                            <h4>‚ö° PowerShell Remoting (Windows)</h4>
                            <ul>
                                <li><strong>Protocol:</strong> WS-Management (WinRM)</li>
                                <li><strong>Underlying service:</strong> WinRM</li>
                                <li><strong>Default Ports:</strong> TCP 5985 (HTTP), 5986 (HTTPS)</li>
                                <li><strong>Primary for:</strong> Windows systems</li>
                                <li><strong>Output:</strong> Object-based streams</li>
                                <li><strong>Authentication:</strong> NTLM, Kerberos, CredSSP</li>
                            </ul>
                        </div>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Why PowerShell Remoting is Critical</h4>
                        <p>In modern IT environments, you rarely have physical access to every server. PowerShell Remoting allows you to:</p>
                        <ul>
                            <li>Administer servers efficiently from your workstation</li>
                            <li>Automate tasks across entire server farms</li>
                            <li>Gather data from multiple servers for reporting</li>
                            <li>Troubleshoot issues without logging into each machine individually</li>
                            <li>It's the cornerstone of effective Windows Server automation.</li>
                        </ul>
                    </div>

                    <h3>Module Learning Objectives</h3>
                    <p>By the end of this module, you will be able to:</p>
                    <ul>
                        <li>Configure Windows Remote Management (WinRM) for PowerShell Remoting</li>
                        <li>Execute commands on remote computers using <code>Invoke-Command</code></li>
                        <li>Establish and manage interactive remote sessions with <code>Enter-PSSession</code></li>
                        <li>Create and use persistent PowerShell sessions</li>
                        <li>Understand how data is passed between local and remote scopes</li>
                        <li>Implement security best practices for PowerShell Remoting</li>
                        <li>Troubleshoot common PowerShell Remoting issues</li>
                    </ul>

                    <h3>Prerequisites</h3>
                    <p>Before beginning this module, you should have:</p>
                    <ul>
                        <li>Two Windows Server VMs (one client, one server) or a Windows client and a Windows Server VM.</li>
                        <li>PowerShell Fundamentals (Module 5.3)</li>
                        <li>PowerShell Scripting (Module 5.4)</li>
                        <li>Administrator privileges on both local and remote Windows systems (for setup).</li>
                    </ul>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è Important: Practice in a VM Environment</h4>
                        <p>When working with PowerShell Remoting, especially during initial setup and security configuration, it's crucial to use a controlled virtual machine environment. Incorrect settings can impact network connectivity and security.</p>
                    </div>
                </section>

                <!-- WinRM Configuration Section -->
                <section id="winrm-config" class="section">
                    <h2>WinRM Configuration for PowerShell Remoting</h2>
                    
                    <p>PowerShell Remoting relies on the Windows Remote Management (WinRM) service. This service must be enabled and configured on both the client (where you run commands from) and the server (the target machine).</p>

                    <h3>Enabling PowerShell Remoting</h3>

                    <div class="definition-box">
                        <h4>üìñ Enable-PSRemoting Cmdlet</h4>
                        <p>The <span class="inline-code">Enable-PSRemoting</span> cmdlet configures the computer to receive PowerShell remote commands. It performs the necessary WinRM and firewall setup.</p>
                    </div>

                    <div class="example-box">
                        <h4>Step-by-Step: Enabling Remoting on the Server</h4>
                        <p><strong>On the remote Windows Server (target machine):</strong></p>
                        <div class="code-block"><pre><code># Open PowerShell as Administrator
# Run the following command
Enable-PSRemoting -Force

# -Force parameter suppresses confirmation prompts.
# This command does the following:
# 1. Starts the WinRM service
# 2. Sets the WinRM service to start automatically
# 3. Configures a listener for HTTP or HTTPS
# 4. Creates firewall rules to allow WinRM traffic (ports 5985/5986)</code></pre></div>
                        
                        <p><strong>Verify WinRM status:</strong></p>
                        <div class="code-block"><pre><code># Check WinRM service status
Get-Service -Name WinRM

# Check WinRM listener
Get-WSManInstance -ResourceURI winrm/config/Listener | Format-List</code></pre></div>
                    </div>

                    <h3>Firewall Configuration</h3>

                    <div class="definition-box">
                        <h4>üìñ WinRM Firewall Ports</h4>
                        <p>WinRM uses specific ports for communication:</p>
                        <ul>
                            <li><strong>HTTP:</strong> TCP 5985 (default)</li>
                            <li><strong>HTTPS:</strong> TCP 5986 (more secure, requires SSL certificate)</li>
                        </ul>
                        <p><code>Enable-PSRemoting</code> usually creates the necessary firewall rules. However, it's good to know how to check and manage them manually.</p>
                    </div>

                    <div class="example-box">
                        <h4>Checking and Managing Firewall Rules</h4>
                        <div class="code-block"><pre><code># Check existing WinRM firewall rules
Get-NetFirewallRule -DisplayName "Windows Remote Management*"

# If rules are missing or disabled, you can enable them:
Enable-NetFirewallRule -DisplayName "Windows Remote Management (HTTP-In)"
Enable-NetFirewallRule -DisplayName "Windows Remote Management (HTTPS-In)"

# Or create new rules (if needed, advanced)
# New-NetFirewallRule -DisplayName "WinRM HTTP" -Direction Inbound -LocalPort 5985 -Protocol TCP -Action Allow -Force
# New-NetFirewallRule -DisplayName "WinRM HTTPS" -Direction Inbound -LocalPort 5986 -Protocol TCP -Action Allow -Force</code></pre></div>
                        <p><strong>Note:</strong> In a domain environment, Group Policy is often used to manage WinRM and firewall settings centrally.</p>
                    </div>

                    <h3>TrustedHosts Configuration (Workgroup Environments)</h3>

                    <div class="definition-box">
                        <h4>üìñ TrustedHosts</h4>
                        <p>In a workgroup (non-domain) environment, computers do not implicitly trust each other. You must explicitly add remote computers to the local machine's <strong>TrustedHosts</strong> list to allow unencrypted (HTTP) WinRM communication and credential passing.</p>
                    </div>

                    <div class="example-box">
                        <h4>Configuring TrustedHosts on the Client</h4>
                        <p><strong>On your local Windows client/server (where you initiate commands from):</strong></p>
                        <div class="code-block"><pre><code># Open PowerShell as Administrator

# Get current TrustedHosts list
Get-Item WSMan:\localhost\Client\TrustedHosts

# Add a single remote computer (replace with remote server's IP/hostname)
Set-Item WSMan:\localhost\Client\TrustedHosts -Value "192.168.1.100" -Force

# Add multiple remote computers
Set-Item WSMan:\localhost\Client\TrustedHosts -Value "Server01, Server02, 192.168.1.101" -Force

# Add all computers (wildcard - use with extreme caution in production!)
Set-Item WSMan:\localhost\Client\TrustedHosts -Value "*" -Force

# To append to existing list
# $currentTrustedHosts = (Get-Item WSMan:\localhost\Client\TrustedHosts).Value
# Set-Item WSMan:\localhost\Client\TrustedHosts -Value "$currentTrustedHosts, NewServer" -Force

# To remove TrustedHosts (for security reasons)
# Clear-Item WSMan:\localhost\Client\TrustedHosts -Force</code></pre></div>
                        <p><strong>Important:</strong> Changes to TrustedHosts only affect the client configuration, not the server.</p>
                    </div>

                    <div class="security-box">
                        <h4>‚ö†Ô∏è Security Warning: TrustedHosts and HTTP</h4>
                        <p>Adding a remote computer to TrustedHosts allows it to send credentials over HTTP (port 5985) if HTTPS is not configured. This is a security risk on untrusted networks. Always use HTTPS (port 5986) or be in a trusted domain environment where Kerberos handles authentication securely.</p>
                    </div>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: WinRM Setup</h4>
                        <p>Perform these steps on your Windows Server VM (as target) and your Windows client/another Windows Server VM (as source):</p>
                        <ol>
                            <li><strong>On the Target Server:</strong> Run <span class="inline-code">Enable-PSRemoting -Force</span> as Administrator.</li>
                            <li><strong>On the Target Server:</strong> Verify the WinRM service is running and firewall rules are active.</li>
                            <li><strong>On the Client:</strong> If in a workgroup, add the Target Server's IP address or hostname to your client's TrustedHosts list.</li>
                            <li><strong>On the Client:</strong> Test basic WinRM connectivity: <span class="inline-code">Test-WSMan -ComputerName YourRemoteServerIP</span></li>
                        </ol>
                    </div>

                    <div class="interactive-exercise">
                        <h3>üéØ Interactive Exercise: WinRM Configuration</h3>
                        
                        <div class="exercise-question">
                            <p><strong>Question:</strong> Which cmdlet is used to enable PowerShell Remoting on a Windows Server?</p>
                        </div>
                        
                        <div class="exercise-options">
                            <label class="exercise-option">
                                <input type="radio" name="q1" value="a">
                                <span><code>Start-WinRMService</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q1" value="b">
                                <span><code>Enable-PSRemoting</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q1" value="c">
                                <span><code>Set-RemoteAccess</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q1" value="d">
                                <span><code>Configure-WinRM</code></span>
                            </label>
                        </div>
                        
                        <button class="check-answer-btn" onclick="checkAnswer('q1', 'b', 'feedback1')">Check Answer</button>
                        <div id="feedback1" class="feedback"></div>
                    </div>
                </section>

                <!-- Invoke-Command Section -->
                <section id="invoke-command" class="section">
                    <h2>Invoke-Command: Running Commands Remotely</h2>
                    
                    <p>The <span class="inline-code">Invoke-Command</span> cmdlet is the primary tool for running commands or script blocks on one or more remote computers. It's designed for one-to-many execution and is ideal for automation.</p>

                    <h3>Basic Invoke-Command Syntax</h3>

                    <div class="definition-box">
                        <h4>üìñ Invoke-Command Cmdlet</h4>
                        <p><span class="inline-code">Invoke-Command</span> executes a command or script block on a remote computer. It establishes a temporary connection, runs the command, and returns the results.</p>
                        
                        <div class="code-block"><pre><code>Invoke-Command -ComputerName <String[]> -ScriptBlock { <ScriptBlock> } [-Credential <PSCredential>]</code></pre></div>
                    </div>

                    <div class="example-box">
                        <h4>Executing Single Commands Remotely</h4>
                        <p><strong>Example 1: Get-Service on a remote server</strong></p>
                        <div class="code-block"><pre><code># Replace 'YourRemoteServerIP' with the actual IP or hostname
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock { Get-Service WinRM }

# Output will show the WinRM service object from the remote machine.
# Note: The output includes a 'PSComputerName' property indicating the source.</code></pre></div>
                        
                        <p><strong>Example 2: Get-Process on multiple servers</strong></p>
                        <div class="code-block"><pre><code># Define an array of server names
$servers = @("YourRemoteServerIP", "AnotherRemoteServerIP") # Add more IPs/hostnames

# Run Get-Process on all servers
Invoke-Command -ComputerName $servers -ScriptBlock { Get-Process -Name "explorer" }</code></pre></div>
                        
                        <p><strong>Example 3: Running a simple script block</strong></p>
                        <div class="code-block"><pre><code>Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    $osInfo = Get-CimInstance Win32_OperatingSystem
    Write-Output "Remote OS Version: $($osInfo.Caption)"
    Write-Output "Remote OS Build: $($osInfo.BuildNumber)"
}</code></pre></div>
                    </div>

                    <h3>Using Credentials with Invoke-Command</h3>

                    <div class="definition-box">
                        <h4>üìñ Credential Parameter</h4>
                        <p>By default, <span class="inline-code">Invoke-Command</span> uses your current logged-in user's credentials. If the remote computer is not in the same domain or you need different credentials, use the <span class="inline-code">-Credential</span> parameter.</p>
                    </div>

                    <div class="example-box">
                        <h4>Providing Credentials</h4>
                        <div class="code-block"><pre><code># Method 1: Prompt for credentials
$cred = Get-Credential
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock { Get-Service } -Credential $cred

# Method 2: Store credentials (use with caution in scripts)
$username = "RemoteAdmin"
$password = ConvertTo-SecureString "YourPasswordHere" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($username, $password)
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock { Get-Service } -Credential $cred</code></pre></div>
                        <p><strong>Note:</strong> Storing plain-text passwords in scripts is a security risk. Use <span class="inline-code">Get-Credential</span> for interactive use or secure methods for automation (e.g., encrypted credential files, Just Enough Administration).</p>
                    </div>

                    <h3>Passing Local Variables to Remote Script Blocks</h3>

                    <div class="definition-box">
                        <h4>üìñ ArgumentList and Using Scope</h4>
                        <p>Variables defined locally on your client machine are not automatically available inside the remote <span class="inline-code">-ScriptBlock</span>. You need to explicitly pass them using <span class="inline-code">-ArgumentList</span> or the <span class="inline-code">$using:</span> scope modifier.</p>
                    </div>

                    <div class="example-box">
                        <h4>Passing Variables Examples</h4>
                        <p><strong>Example 1: Using -ArgumentList (recommended for values)</strong></p>
                        <div class="code-block"><pre><code># Local variable
$serviceName = "Spooler"

Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock { 
    param($RemoteServiceName) # Define parameter in script block
    Get-Service -Name $RemoteServiceName 
} -ArgumentList $serviceName

# For multiple arguments
$path = "C:\Temp"
$days = 7
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    param($RemotePath, $RemoteDays)
    Get-ChildItem -Path $RemotePath | Where-Object {$_.LastWriteTime -lt (Get-Date).AddDays(-$RemoteDays)}
} -ArgumentList $path, $days</code></pre></div>
                        
                        <p><strong>Example 2: Using $using: scope modifier (recommended for complex objects or expressions)</strong></p>
                        <div class="code-block"><pre><code># Local variable
$remotePath = "C:\Windows\System32"

Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    # Access local variable directly using $using:
    Get-ChildItem -Path $using:remotePath | Measure-Object -Property Length -Sum
}</code></pre></div>
                        <p><strong>Important:</strong> The <span class="inline-code">$using:</span> scope modifier is evaluated *locally* before the script block is sent to the remote machine. It's useful for injecting local variable values into the remote script block.</p>
                    </div>

                    <h3>Asynchronous Execution with -AsJob</h3>

                    <div class="definition-box">
                        <h4>üìñ -AsJob Parameter</h4>
                        <p>The <span class="inline-code">-AsJob</span> parameter allows you to run remote commands asynchronously in the background. This is useful for long-running tasks or when managing many remote computers.</p>
                    </div>

                    <div class="example-box">
                        <h4>Running Commands as Jobs</h4>
                        <div class="code-block"><pre><code># Start a remote command as a job
$job = Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock { Start-Sleep -Seconds 30; Get-Service } -AsJob

# View running jobs
Get-Job

# Wait for the job to complete
Wait-Job -Job $job

# Retrieve results
Receive-Job -Job $job

# Remove the job
Remove-Job -Job $job</code></pre></div>
                    </div>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: Invoke-Command</h4>
                        <p>Ensure WinRM is enabled on your remote server VM first.</p>
                        <ol>
                            <li>Use <span class="inline-code">Invoke-Command</span> to run <span class="inline-code">Get-ComputerInfo | Select-Object CsName, WindowsProductName</span> on your remote server.</li>
                            <li>Use <span class="inline-code">Invoke-Command</span> with the <span class="inline-code">-Credential</span> parameter to connect as a different user (e.g., a local admin account on the remote server).</li>
                            <li>Create a local variable, e.g., <span class="inline-code">$remoteFile = "C:\Windows\system.ini"</span>. Then use <span class="inline-code">Invoke-Command</span> with <span class="inline-code">$using:remoteFile</span> to get the content of that file remotely.</li>
                            <li>Run a long-running command (e.g., <span class="inline-code">Start-Sleep -Seconds 60; Get-Date</span>) on the remote server using <span class="inline-code">-AsJob</span>. Then retrieve its status and results.</li>
                        </ol>
                    </div>

                    <div class="interactive-exercise">
                        <h3>üéØ Interactive Exercise: Invoke-Command</h3>
                        
                        <div class="exercise-question">
                            <p><strong>Question:</strong> How do you pass a local variable named `$myVar` to a remote script block using `Invoke-Command`?</p>
                        </div>
                        
                        <div class="exercise-options">
                            <label class="exercise-option">
                                <input type="radio" name="q2" value="a">
                                <span><code>Invoke-Command -ComputerName $server -ScriptBlock { Write-Host $myVar }</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q2" value="b">
                                <span><code>Invoke-Command -ComputerName $server -ScriptBlock { Write-Host $using:myVar }</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q2" value="c">
                                <span><code>Invoke-Command -ComputerName $server -ScriptBlock { Write-Host $_.myVar }</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q2" value="d">
                                <span><code>Invoke-Command -ComputerName $server -ScriptBlock { Write-Host $ExecutionContext.myVar }</code></span>
                            </label>
                        </div>
                        
                        <button class="check-answer-btn" onclick="checkAnswer('q2', 'b', 'feedback2')">Check Answer</button>
                        <div id="feedback2" class="feedback"></div>
                    </div>
                </section>

                <!-- PowerShell Sessions Section -->
                <section id="pssession" class="section">
                    <h2>PowerShell Sessions (PSSessions)</h2>
                    
                    <p>While <span class="inline-code">Invoke-Command</span> creates a temporary session for each execution, <strong>PSSessions</strong> provide persistent connections to remote computers. This is efficient for running multiple commands on the same remote machine without re-establishing the connection each time.</p>

                    <h3>Interactive Sessions with Enter-PSSession</h3>

                    <div class="definition-box">
                        <h4>üìñ Enter-PSSession Cmdlet</h4>
                        <p><span class="inline-code">Enter-PSSession</span> establishes an interactive remote session, similar to SSH for Linux. You get a remote prompt and can run commands directly on the remote computer.</p>
                    </div>

                    <div class="example-box">
                        <h4>Starting and Exiting an Interactive Session</h4>
                        <div class="code-block"><pre><code># Open an interactive session to a remote server
Enter-PSSession -ComputerName "YourRemoteServerIP" -Credential (Get-Credential)

# You will see a remote prompt:
# [YourRemoteServerIP]: PS C:\Users\Administrator\Documents>

# Now you can run commands directly on the remote server:
Get-Service WinRM
Get-Process notepad

# To exit the remote session and return to your local prompt:
Exit-PSSession</code></pre></div>
                        <p><strong>Note:</strong> When in an interactive session, commands run directly on the remote computer's context. Local variables are not available unless explicitly passed or created.</p>
                    </div>

                    <h3>Persistent Sessions with New-PSSession</h3>

                    <div class="definition-box">
                        <h4>üìñ New-PSSession Cmdlet</h4>
                        <p><span class="inline-code">New-PSSession</span> creates a persistent session object that can be reused for multiple commands. This is more efficient for repeated operations on the same remote computer.</p>
                    </div>

                    <div class="example-box">
                        <h4>Creating and Using Persistent Sessions</h4>
                        <p><strong>Example 1: Create and use a PSSession</strong></p>
                        <div class="code-block"><pre><code># Create a new persistent session
$session = New-PSSession -ComputerName "YourRemoteServerIP" -Credential (Get-Credential)

# Run commands using the session (no need to re-authenticate)
Invoke-Command -Session $session -ScriptBlock { Get-Service WinRM }
Invoke-Command -Session $session -ScriptBlock { Get-Process explorer }

# You can even enter the persistent session interactively
Enter-PSSession -Session $session

# Inside the remote session, make a change
# [YourRemoteServerIP]: PS C:\> New-Item -Path C:\Temp\RemoteFile.txt -ItemType File

# Exit the interactive session
Exit-PSSession

# The change persists in the remote session. You can verify:
Invoke-Command -Session $session -ScriptBlock { Get-ChildItem C:\Temp\RemoteFile.txt }</code></pre></div>
                        
                        <p><strong>Example 2: Create multiple sessions</strong></p>
                        <div class="code-block"><pre><code>$servers = @("YourRemoteServerIP", "AnotherRemoteServerIP")
$sessions = New-PSSession -ComputerName $servers -Credential (Get-Credential)

# Run commands on all sessions
Invoke-Command -Session $sessions -ScriptBlock { Get-Service -Name "Spooler" }</code></pre></div>
                    </div>

                    <h3>Managing PSSessions</h3>

                    <div class="definition-box">
                        <h4>üìñ Get-PSSession and Remove-PSSession</h4>
                        <p><span class="inline-code">Get-PSSession</span> lists all active PSSessions. <span class="inline-code">Remove-PSSession</span> closes and cleans up PSSessions.</p>
                    </div>

                    <div class="example-box">
                        <h4>Listing and Removing Sessions</h4>
                        <div class="code-block"><pre><code># Get all active PSSessions
Get-PSSession

# Get specific session by ID or Name
Get-PSSession -Id 1
Get-PSSession -Name "Session1"

# Remove a specific session
Remove-PSSession -Id 1
Remove-PSSession -Session $session

# Remove all active sessions
Get-PSSession | Remove-PSSession</code></pre></div>
                        <p><strong>Important:</strong> Always remove PSSessions when you're done with them to free up resources on both the client and server.</p>
                    </div>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: PSSessions</h4>
                        <ol>
                            <li>Use <span class="inline-code">Enter-PSSession</span> to connect interactively to your remote server. Run a few commands, create a file, then <span class="inline-code">Exit-PSSession</span>. Verify the file exists locally.</li>
                            <li>Create a persistent session using <span class="inline-code">New-PSSession</span>. Store it in a variable.</li>
                            <li>Use <span class="inline-code">Invoke-Command -Session $yourSessionVariable</span> to run <span class="inline-code">Get-Date</span> on the remote server.</li>
                            <li>Enter the persistent session interactively, create another file, then exit. Verify the file exists.</li>
                            <li>Use <span class="inline-code">Get-PSSession</span> to list your active sessions.</li>
                            <li>Use <span class="inline-code">Remove-PSSession</span> to close all active sessions.</li>
                        </ol>
                    </div>

                    <div class="interactive-exercise">
                        <h3>üéØ Interactive Exercise: PSSessions</h3>
                        
                        <div class="exercise-question">
                            <p><strong>Question:</strong> Which cmdlet allows you to establish a persistent, reusable connection to a remote computer?</p>
                        </div>
                        
                        <div class="exercise-options">
                            <label class="exercise-option">
                                <input type="radio" name="q3" value="a">
                                <span><code>Invoke-Command</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q3" value="b">
                                <span><code>Enter-PSSession</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q3" value="c">
                                <span><code>New-PSSession</code></span>
                            </label>
                            <label class="exercise-option">
                                <input type="radio" name="q3" value="d">
                                <span><code>Connect-Remote</code></span>
                            </label>
                        </div>
                        
                        <button class="check-answer-btn" onclick="checkAnswer('q3', 'c', 'feedback3')">Check Answer</button>
                        <div id="feedback3" class="feedback"></div>
                    </div>
                </section>

                <!-- Data Transfer & Scope Section -->
                <section id="data-transfer" class="section">
                    <h2>Data Transfer and Scope in Remoting</h2>
                    
                    <p>Understanding how data and variables behave across local and remote scopes is crucial for writing effective remote PowerShell scripts.</p>

                    <h3>Input and Output with Remoting</h3>

                    <div class="definition-box">
                        <h4>üìñ Object Serialization</h4>
                        <p>When objects are sent across the network via PowerShell Remoting, they are <strong>serialized</strong> (converted to XML or JSON) on the sending side and then <strong>deserialized</strong> (reconverted to objects) on the receiving side. This means that methods are lost, and only properties are preserved for deserialized objects. However, for most common cmdlets, PowerShell automatically "rehydrates" them into live objects with methods.</p>
                    </div>

                    <div class="example-box">
                        <h4>Inputting Data to Remote Commands</h4>
                        <p><strong>Example 1: Using -ArgumentList (for single values/variables)</strong></p>
                        <div class="code-block"><pre><code># Local variable
$localService = "BITS"

# Pass to remote script block
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    param($ServiceToGet)
    Get-Service -Name $ServiceToGet
} -ArgumentList $localService</code></pre></div>
                        
                        <p><strong>Example 2: Using $using: (for complex objects/expressions)</strong></p>
                        <div class="code-block"><pre><code># Local DateTime object
$localDate = (Get-Date).AddDays(-7)

# Pass to remote script block
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    Get-WinEvent -LogName System -FilterXPath "*[System[(TimeCreated[@SystemTime > '$($using:localDate.ToUniversalTime().ToString("o"))'])]]"
}</code></pre></div>
                        
                        <p><strong>Example 3: Piping objects to remote commands</strong></p>
                        <div class="code-block"><pre><code># Get local services, then pipe to remote command
Get-Service -Name "WinRM", "Spooler" | Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    # $_ represents the piped-in service object from local machine
    # Note: These are deserialized objects, not live objects on the remote machine
    # You would typically re-query or use properties
    Write-Host "Received service: $($_.Name) with status $($_.Status)"
}</code></pre></div>
                        <p><strong>Important:</strong> When piping objects directly, the remote script block receives the *deserialized* object, not the live object from the remote machine. If you need to perform methods on the object remotely, you might need to re-query the object on the remote side.</p>
                    </div>

                    <div class="example-box">
                        <h4>Outputting Data from Remote Commands</h4>
                        <div class="code-block"><pre><code># Remote output is returned as objects
$remoteProcesses = Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock { Get-Process }

# You can then process these objects locally
$remoteProcesses | Where-Object {$_.ProcessName -like "chrome*"} | Select-Object ProcessName, Id, CPU, PSComputerName</code></pre></div>
                        <p>Each object returned from a remote command will have an additional `PSComputerName` property indicating which remote computer it came from.</p>
                    </div>

                    <h3>Remote Script Execution</h3>

                    <div class="example-box">
                        <h4>Running a Local Script on a Remote Computer</h4>
                        <div class="code-block"><pre><code># Create a local script file (e.g., C:\Scripts\RemoteHealthCheck.ps1)
# C:\Scripts\RemoteHealthCheck.ps1
# ----------------------------------
# Write-Host "--- Remote Health Check ---"
# Get-Service | Where-Object {$_.Status -eq "Stopped"} | Select-Object Name, Status
# Get-Process | Sort-Object CPU -Descending | Select-Object -First 5 ProcessName, CPU
# ----------------------------------

# Invoke the local script on the remote computer
Invoke-Command -ComputerName "YourRemoteServerIP" -FilePath "C:\Scripts\RemoteHealthCheck.ps1"

# You can also use a script block directly
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    # All code here runs on the remote machine
    $report = @{}
    $report.OS = (Get-ComputerInfo).WindowsProductName
    $report.RunningServices = (Get-Service | Where-Object Status -eq "Running").Count
    return $report # Return an object
}</code></pre></div>
                    </div>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: Data Transfer</h4>
                        <ol>
                            <li>Create a local variable <span class="inline-code">$remoteDrive = "C:"</span>. Use <span class="inline-code">Invoke-Command</span> with <span class="inline-code">$using:remoteDrive</span> to run <span class="inline-code">Get-PSDrive -Name $using:remoteDrive</span> on your remote server.</li>
                            <li>Create a local array of service names: <span class="inline-code">$myServices = @("WinRM", "Spooler")</span>. Pipe this array to <span class="inline-code">Invoke-Command</span> to run <span class="inline-code">Get-Service -Name $_.Name</span> on the remote server. Observe the output.</li>
                            <li>Create a simple local script (e.g., <span class="inline-code">C:\Temp\RemoteTest.ps1</span>) that outputs <span class="inline-code">Get-Date</span> and <span class="inline-code">hostname</span>. Use <span class="inline-code">Invoke-Command -FilePath</span> to run it remotely.</li>
                        </ol>
                    </div>
                </section>

                <!-- Security Section -->
                <section id="security" class="section">
                    <h2>Security and Authentication in PowerShell Remoting</h2>
                    
                    <p>PowerShell Remoting is designed with security in mind, but proper configuration and understanding of authentication mechanisms are crucial.</p>

                    <h3>Authentication Protocols</h3>

                    <div class="definition-box">
                        <h4>üìñ Authentication Mechanisms</h4>
                        <p>PowerShell Remoting primarily uses the following authentication protocols:</p>
                        <ul>
                            <li><strong>Kerberos:</strong> Default for domain environments, provides mutual authentication and delegation.</li>
                            <li><strong>NTLM:</strong> Used for workgroup environments or when Kerberos fails. Less secure as it doesn't support delegation and is vulnerable to pass-the-hash attacks.</li>
                            <li><strong>CredSSP (Credential Security Support Provider):</strong> Allows the client to delegate credentials to the remote server, enabling the remote server to access other network resources on behalf of the user. Highly powerful, use with extreme caution.</li>
                        </ul>
                    </div>

                    <div class="example-box">
                        <h4>Configuring CredSSP (for multi-hop scenarios)</h4>
                        <p><strong>On the Client:</strong></p>
                        <div class="code-block"><pre><code># Enable CredSSP on the client to allow credential delegation
Enable-WSManCredSSP -Role Client -DelegateComputer "YourRemoteServerIP" -Force</code></pre></div>
                        
                        <p><strong>On the Server:</strong></p>
                        <div class="code-block"><pre><code># Enable CredSSP on the server to allow it to receive delegated credentials
Enable-WSManCredSSP -Role Server -Force</code></pre></div>
                        
                        <p><strong>When invoking commands:</strong></p>
                        <div class="code-block"><pre><code># Use CredSSP authentication
Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock {
    # This command would then run on a third server from 'YourRemoteServerIP'
    Invoke-Command -ComputerName "ThirdServerIP" -ScriptBlock { Get-Service }
} -Authentication Credssp -Credential (Get-Credential)</code></pre></div>
                        <p><strong>Warning:</strong> CredSSP is a high-security risk if not managed carefully, as it sends your plain-text credentials to the remote server. Only use it when absolutely necessary (e.g., multi-hop remoting) and ensure strong security around the servers.</p>
                    </div>

                    <h3>WinRM HTTPS Listener</h3>

                    <div class="security-box">
                        <h4>üîê Encrypting WinRM Traffic with HTTPS</h4>
                        <p>By default, WinRM uses HTTP on port 5985. While traffic is encrypted even over HTTP, configuring an HTTPS listener on port 5986 provides an additional layer of security by ensuring certificate-based encryption from the start.</p>
                        
                        <p><strong>Steps:</strong></p>
                        <ol>
                            <li><strong>Install an SSL Certificate:</strong> Obtain a valid SSL certificate for your server (from a CA or self-signed for testing).</li>
                            <li><strong>Create HTTPS Listener:</strong></li>
                        </ol>
                        <div class="code-block"><pre><code># Assuming you have a certificate with the server's hostname or IP in its Subject Alternative Name (SAN)
# Get the certificate thumbprint
$cert = Get-ChildItem Cert:\LocalMachine\My | Where-Object {$_.Subject -like "*YourServerHostname*"}
$thumbprint = $cert.Thumbprint

# Create the HTTPS listener
winrm create winrm/config/Listener?Address=*+Transport=HTTPS @{Hostname="YourServerHostname"; CertificateThumbprint="$thumbprint"}

# Verify the listener
Get-WSManInstance -ResourceURI winrm/config/Listener | Format-List</code></pre></div>
                        <p>Once configured, you can specify <span class="inline-code">-UseSSL</span> when invoking commands:</p>
                        <div class="code-block"><pre><code>Invoke-Command -ComputerName "YourRemoteServerIP" -ScriptBlock { Get-Date } -UseSSL</code></pre></div>
                    </div>

                    <h3>JEA (Just Enough Administration)</h3>

                    <div class="definition-box">
                        <h4>üìñ Just Enough Administration (JEA)</h4>
                        <p><strong>JEA</strong> is a PowerShell security technology that enables delegated administration for anything that can be managed with PowerShell. It allows you to create administrative roles that grant specific users only the cmdlets and parameters they need to perform their jobs, without giving them full administrator access.</p>
                        <p><strong>Benefits:</strong> Reduces attack surface, enforces least privilege, provides auditing.</p>
                        <p><strong>Note:</strong> JEA is an advanced topic not covered in detail in this module, but it's a critical aspect of secure PowerShell Remoting in production environments.</p>
                    </div>

                    <div class="security-box">
                        <h4>üîê Security Best Practices for PowerShell Remoting</h4>
                        <ol>
                            <li><strong>Use Least Privilege:</strong> Always use credentials with the minimum necessary permissions.</li>
                            <li><strong>Domain Environment:</strong> Leverage Kerberos authentication in a domain.</li>
                            <li><strong>HTTPS Listener:</strong> Configure WinRM to use HTTPS (port 5986) for encrypted traffic.</li>
                            <li><strong>Firewall Rules:</strong> Restrict WinRM inbound access (ports 5985/5986) to trusted IP ranges only.</li>
                            <li><strong>TrustedHosts:</strong> Be judicious with TrustedHosts in workgroups; avoid wildcards (`*`).</li>
                            <li><strong>CredSSP Caution:</strong> Only use CredSSP when absolutely required and understand the risks.</li>
                            <li><strong>Session Configuration:</strong> Restrict capabilities of default session configurations or create custom ones.</li>
                            <li><strong>JEA:</strong> For production, implement Just Enough Administration.</li>
                            <li><strong>Auditing:</strong> Log remote command execution for accountability.</li>
                            <li><strong>Keep Updated:</strong> Ensure Windows Server and PowerShell are patched.</li>
                        </ol>
                    </div>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: Remoting Security</h4>
                        <ol>
                            <li>(Optional, for advanced users/testing only): Experiment with configuring a self-signed SSL certificate and an HTTPS listener for WinRM.</li>
                            <li>(Highly Recommended): Review your Windows Firewall settings on your remote server to ensure WinRM ports are not open to the entire internet. Restrict them to your local network or specific client IP addresses.</li>
                            <li>Disable CredSSP on both client and server if you enabled it for testing.</li>
                        </ol>
                    </div>
                </section>

                <!-- Best Practices & Troubleshooting Section -->
                <section id="best-practices" class="section">
                    <h2>Best Practices and Troubleshooting</h2>
                    
                    <p>To maximize efficiency and reliability when using PowerShell Remoting, follow these best practices and learn how to diagnose common issues.</p>

                    <h3>PowerShell Remoting Best Practices</h3>

                    <div class="tip-box">
                        <h4>üí° Tips for Effective Remoting</h4>
                        <ul>
                            <li><strong>Filter Left, Format Right:</strong> Perform filtering (Where-Object) early in the pipeline on the remote machine to reduce data transfer. Perform formatting (Format-Table, Format-List) locally after data is received.</li>
                            <li><strong>Use PSSessions for Multiple Commands:</strong> For repeated commands on the same remote server, create a persistent PSSession with <code>New-PSSession</code> to avoid connection overhead.</li>
                            <li><strong>Batch Commands:</strong> Group multiple commands into a single script block for <code>Invoke-Command</code> to minimize network round trips.</li>
                            <li><strong>Explicit Credentials:</strong> Always use the <code>-Credential</code> parameter for clarity and security, especially in scripts.</li>
                            <li><strong>Error Handling:</strong> Implement robust error handling (<code>try/catch</code> with <code>-ErrorAction Stop</code>) for remote commands.</li>
                            <li><strong>Test-WSMan:</strong> Use <code>Test-WSMan</code> as your first diagnostic tool to verify basic WinRM connectivity.</li>
                            <li><strong>Use -AsJob:</strong> For long-running or parallel tasks on many servers, use <code>-AsJob</code> to avoid blocking your console.</li>
                            <li><strong>Avoid Interactive Sessions in Scripts:</strong> <code>Enter-PSSession</code> is for interactive troubleshooting, not for automation scripts.</li>
                        </ul>
                    </div>

                    <h3>Common Troubleshooting Scenarios</h3>

                    <div class="warning-box">
                        <h4>Problem 1: Access Denied</h4>
                        <div class="code-block"><pre><code># Error: Access is denied.
# Error: Connecting to remote server failed with the following error message : Access is denied.</code></pre></div>
                        <p><strong>Causes:</strong></p>
                        <ul>
                            <li>Incorrect username/password.</li>
                            <li>User account lacks remote management permissions.</li>
                            <li>Remote computer not in TrustedHosts (workgroup).</li>
                            <li>Firewall blocking ports.</li>
                        </ul>
                        <p><strong>Solutions:</strong></p>
                        <ul>
                            <li>Verify credentials.</li>
                            <li>Ensure user is in 'Administrators' group or 'Remote Management Users' group on the remote machine.</li>
                            <li>Check TrustedHosts on client.</li>
                            <li>Check firewall on server.</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <h4>Problem 2: WinRM Service Not Running / Cannot Connect</h4>
                        <div class="code-block"><pre><code># Error: The WinRM client cannot process the request. The WinRM service is not running on ...</code></pre></div>
                        <p><strong>Causes:</strong></p>
                        <ul>
                            <li>WinRM service is stopped on remote machine.</li>
                            <li>WinRM service is not configured to start automatically.</li>
                            <li>Network connectivity issues (ping, DNS).</li>
                        </ul>
                        <p><strong>Solutions:</strong></p>
                        <ul>
                            <li>On remote machine: <span class="inline-code">Get-Service WinRM</span>, <span class="inline-code">Start-Service WinRM</span>, <span class="inline-code">Set-Service WinRM -StartupType Automatic</span>.</li>
                            <li>Check network connectivity (<span class="inline-code">ping</span>, <span class="inline-code">Test-NetConnection -ComputerName YourRemoteServerIP -Port 5985</span>).</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <h4>Problem 3: Firewall Blocking Access</h4>
                        <div class="code-block"><pre><code># Error: The WinRM client cannot process the request. It cannot connect to the destination specified in the request.</code></pre></div>
                        <p><strong>Causes:</strong></p>
                        <ul>
                            <li>Windows Firewall on remote machine is blocking WinRM ports (5985/5986).</li>
                            <li>Network firewall (hardware) is blocking WinRM ports.</li>
                        </ul>
                        <p><strong>Solutions:</strong></p>
                        <ul>
                            <li>On remote machine: <span class="inline-code">Get-NetFirewallRule -DisplayName "Windows Remote Management*"</span> to verify rules are enabled.</li>
                            <li>Temporarily disable firewall for testing (<strong>NOT in production!</strong>): <span class="inline-code">Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False</span>.</li>
                            <li>Consult network team for hardware firewall configuration.</li>
                        </ul>
                    </div>

                    <h3>Diagnostic Tools</h3>

                    <table class="command-table">
                        <thead>
                            <tr>
                                <th>Tool/Cmdlet</th>
                                <th>Purpose</th>
                                <th>Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>Test-WSMan</code></td>
                                <td>Verify basic WinRM connectivity</td>
                                <td><code>Test-WSMan -ComputerName Server01</code></td>
                            </tr>
                            <tr>
                                <td><code>winrm qc</code></td>
                                <td>Quick config WinRM (server-side)</td>
                                <td><code>winrm qc -Force</code></td>
                            </tr>
                            <tr>
                                <td><code>Get-NetFirewallRule</code></td>
                                <td>Check firewall rules</td>
                                <td><code>Get-NetFirewallRule -DisplayName "Windows Remote Management*"</code></td>
                            </tr>
                            <tr>
                                <td><code>Test-NetConnection</code></td>
                                <td>Test network/port connectivity</td>
                                <td><code>Test-NetConnection -ComputerName Server01 -Port 5985</code></td>
                            </tr>
                            <tr>
                                <td><code>Invoke-Command -Verbose</code></td>
                                <td>Detailed remote execution info</td>
                                <td><code>Invoke-Command ... -Verbose</code></td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: Troubleshooting</h4>
                        <ol>
                            <li>Intentionally stop the WinRM service on your remote server. Try to <span class="inline-code">Invoke-Command</span> from your client and observe the error. Restart the service and retry.</li>
                            <li>(If comfortable) Temporarily disable the WinRM firewall rule on your remote server. Try to <span class="inline-code">Invoke-Command</span> and observe. Re-enable the rule.</li>
                            <li>Use <span class="inline-code">Test-WSMan</span> and <span class="inline-code">Test-NetConnection</span> to diagnose connectivity issues between your client and server.</li>
                        </ol>
                    </div>
                </section>

                <!-- Summary Section -->
                <section id="summary" class="section">
                    <h2>Module 5.6 Summary & Review</h2>
                    
                    <p>Congratulations on completing Module 5.6! You've learned the essential skills for secure and efficient remote management of Windows Server systems using PowerShell Remoting.</p>

                    <div class="key-takeaways">
                        <h3>üéØ Key Concepts Mastered</h3>
                        
                        <h4>PowerShell Remoting Fundamentals</h4>
                        <ul>
                            <li>PowerShell Remoting uses WS-Management (WinRM)</li>
                            <li>It's object-based, secure, and scalable</li>
                            <li>Default ports: 5985 (HTTP), 5986 (HTTPS)</li>
                        </ul>

                        <h4>WinRM Configuration</h4>
                        <ul>
                            <li><code>Enable-PSRemoting</code> configures the server</li>
                            <li>Firewall rules must allow WinRM traffic</li>
                            <li><code>TrustedHosts</code> is needed for workgroup environments</li>
                        </ul>

                        <h4>Remote Command Execution</h4>
                        <ul>
                            <li><code>Invoke-Command</code> runs script blocks on remote computers</li>
                            <li>Pass local variables with <code>-ArgumentList</code> or <code>$using:</code></li>
                            <li><code>-AsJob</code> runs commands asynchronously</li>
                            <li><code>-FilePath</code> executes local scripts remotely</li>
                        </ul>

                        <h4>PowerShell Sessions (PSSessions)</h4>
                        <ul>
                            <li><code>Enter-PSSession</code> for interactive remote sessions</li>
                            <li><code>New-PSSession</code> for persistent, reusable connections</li>
                            <li><code>Get-PSSession</code> and <code>Remove-PSSession</code> to manage sessions</li>
                        </ul>

                        <h4>Security and Authentication</h4>
                        <ul>
                            <li>Kerberos (domain) and NTLM (workgroup) authentication</li>
                            <li>CredSSP for delegation (use with extreme caution)</li>
                            <li>Configure HTTPS listener for enhanced security</li>
                            <li>JEA for granular delegated administration (advanced)</li>
                        </ul>

                        <h4>Best Practices & Troubleshooting</h4>
                        <ul>
                            <li>Filter left, format right; batch commands; use PSSessions for efficiency</li>
                            <li>Use <code>Test-WSMan</code> and verbose output for diagnostics</li>
                            <li>Common issues: Access Denied, WinRM not running, firewall blocks</li>
                        </ul>
                    </div>

                    <h3>PowerShell Remoting Command Reference</h3>

                    <table class="command-table">
                        <thead>
                            <tr>
                                <th>Task</th>
                                <th>Cmdlet / Command</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Enable Remoting (Server)</td>
                                <td><code>Enable-PSRemoting -Force</code></td>
                            </tr>
                            <tr>
                                <td>Check WinRM status</td>
                                <td><code>Get-Service WinRM</code></td>
                            </tr>
                            <tr>
                                <td>Test WinRM connectivity</td>
                                <td><code>Test-WSMan -ComputerName ServerIP</code></td>
                            </tr>
                            <tr>
                                <td>Add to TrustedHosts (Client)</td>
                                <td><code>Set-Item WSMan:\localhost\Client\TrustedHosts -Value ServerIP</code></td>
                            </tr>
                            <tr>
                                <td>Run remote command</td>
                                <td><code>Invoke-Command -ComputerName ServerIP -ScriptBlock { Get-Service }</code></td>
                            </tr>
                            <tr>
                                <td>Enter interactive session</td>
                                <td><code>Enter-PSSession -ComputerName ServerIP</code></td>
                            </tr>
                            <tr>
                                <td>Create persistent session</td>
                                <td><code>$s = New-PSSession -ComputerName ServerIP</code></td>
                            </tr>
                            <tr>
                                <td>Use persistent session</td>
                                <td><code>Invoke-Command -Session $s -ScriptBlock { Get-Process }</code></td>
                            </tr>
                            <tr>
                                <td>Close sessions</td>
                                <td><code>Get-PSSession | Remove-PSSession</code></td>
                            </tr>
                            <tr>
                                <td>Pass local variable</td>
                                <td><code>$myVar = "value"; Invoke-Command ... -ScriptBlock { $using:myVar }</code></td>
                            </tr>
                            <tr>
                                <td>Run local script remotely</td>
                                <td><code>Invoke-Command -ComputerName ServerIP -FilePath C:\script.ps1</code></td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Next Steps</h3>

                    <div class="tip-box">
                        <h4>üí° Continuing Your Learning</h4>
                        
                        <p><strong>Module 5.7: Scripting Best Practices and Automation Strategies</strong></p>
                        <p>You'll synthesize all your scripting knowledge from Bash and PowerShell, focusing on professional standards and identifying automation opportunities.</p>

                        <p><strong>Practice Recommendations:</strong></p>
                        <ul>
                            <li>Use PowerShell Remoting for daily Windows administration tasks.</li>
                            <li>Automate a simple task (e.g., checking service status) across multiple VMs using <code>Invoke-Command</code>.</li>
                            <li>Practice interactive troubleshooting with <code>Enter-PSSession</code>.</li>
                            <li>Experiment with different authentication methods in your VM environment.</li>
                            <li>Review Microsoft Learn documentation on PowerShell Remoting.</li>
                        </ul>

                        <p><strong>Real-World Application:</strong></p>
                        <ul>
                            <li>Manage cloud-based Windows servers (Azure VMs).</li>
                            <li>Deploy software updates to multiple servers.</li>
                            <li>Collect inventory and configuration data from an entire server farm.</li>
                            <li>Implement scheduled tasks that run remote scripts.</li>
                            <li>Integrate with configuration management tools like DSC or Ansible.</li>
                        </ul>
                    </div>

                    <div class="key-takeaways">
                        <h3>üéì Module 5.6 Complete!</h3>
                        <p>You've successfully completed PowerShell Remoting and Remote Management! You should now be able to:</p>
                        <ul>
                            <li>‚úÖ Configure WinRM on Windows Server systems.</li>
                            <li>‚úÖ Execute commands and scripts remotely using <code>Invoke-Command</code>.</li>
                            <li>‚úÖ Establish and manage interactive and persistent PowerShell sessions.</li>
                            <li>‚úÖ Understand data transfer and variable scope in remote operations.</li>
                            <li>‚úÖ Apply security best practices for PowerShell Remoting.</li>
                            <li>‚úÖ Troubleshoot common remote management issues.</li>
                        </ul>
                        
                        <p style="margin-top: 20px;"><strong>CSLO 1 Connection:</strong> This module directly supports your ability to manage and maintain servers, including OS configuration and access control, specifically in Windows environments.</p>
                        <p>It also directly addresses **Objective 5: Connect to remote systems using SSH (Linux) and PowerShell Remoting (Windows)** and **Objective 10: Apply security best practices for remote command-line access** from the Week 5 Learning Objectives.</p>
                    </div>

                    <div class="navigation-buttons">
                        <button class="nav-btn prev" onclick="showSection('best-practices')">‚Üê Previous: Best Practices & Troubleshooting</button>
                        <button class="nav-btn next" onclick="window.print()">üñ®Ô∏è Print Module</button>
                    </div>
                </section>
            </main>
        </div>

        <footer>
            <p><strong>CSC 152 - Network Operating Systems and Administration</strong></p>
            <p>Module 5.6: PowerShell Remoting and Remote Management (Windows)</p>
            <p style="margin-top: 10px;">Mendocino College | Computer Science Department</p>
            <p style="margin-top: 5px; font-size: 0.9em;">¬© 2026 | Version 1.0 | For Educational Use</p>
        </footer>
    </div>

    <script>
        const sections = ['intro', 'winrm-config', 'invoke-command', 'pssession', 'data-transfer', 'security', 'best-practices', 'summary'];
        let currentSectionIndex = 0;
        let completedSections = new Set();

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(sectionId).classList.add('active');
            
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            const navItems = document.querySelectorAll('.nav-item');
            const targetIndex = sections.indexOf(sectionId);
            if (targetIndex >= 0 && targetIndex < navItems.length) {
                navItems[targetIndex].classList.add('active');
            }
            
            if (currentSectionIndex >= 0) {
                completedSections.add(sections[currentSectionIndex]);
                updateProgress();
            }
            
            currentSectionIndex = sections.indexOf(sectionId);
            document.querySelector('.main-content').scrollTo(0, 0);
        }

        function updateProgress() {
            const total = sections.length;
            const completed = completedSections.size;
            const percentage = Math.round((completed / total) * 100);
            
            document.getElementById('moduleProgress').style.width = percentage + '%';
            document.getElementById('moduleProgress').textContent = percentage + '%';
            document.getElementById('sectionsCompleted').textContent = completed;
            
            document.querySelectorAll('.nav-item').forEach((item, index) => {
                if (completedSections.has(sections[index])) {
                    item.classList.add('completed');
                }
            });
        }

        function checkAnswer(questionName, correctAnswer, feedbackId) {
            const selected = document.querySelector(`input[name="${questionName}"]:checked`);
            const feedback = document.getElementById(feedbackId);
            
            if (!selected) {
                feedback.className = 'feedback incorrect';
                feedback.textContent = '‚ö†Ô∏è Please select an answer.';
                return;
            }
            
            if (selected.value === correctAnswer) {
                feedback.className = 'feedback correct';
                feedback.textContent = '‚úÖ Correct! ' + getExplanation(questionName);
            } else {
                feedback.className = 'feedback incorrect';
                feedback.textContent = '‚ùå Incorrect. ' + getExplanation(questionName);
            }
        }

        function getExplanation(questionName) {
            const explanations = {
                'q1': 'Enable-PSRemoting is the cmdlet specifically designed to enable and configure PowerShell Remoting on a Windows Server, including starting the WinRM service and setting up firewall rules.',
                'q2': 'The $using: scope modifier is used to pass local variables into a remote script block. Without it, the variable would not be recognized in the remote session.',
                'q3': 'New-PSSession creates a persistent, reusable connection (PSSession) to a remote computer. Invoke-Command runs a command, Enter-PSSession provides an interactive shell, but neither creates a reusable session object.'
            };
            return explanations[questionName] || '';
        }

        document.addEventListener('DOMContentLoaded', updateProgress);
    </script>
</body>
</html>
