<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="CSC 152 Module 5.7 - Scripting Best Practices and Automation Strategies for Bash and PowerShell">
    <title>Module 5.7: Scripting Best Practices and Automation Strategies | CSC 152</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #8e44ad; /* Purple for synthesis */
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --info-color: #16a085;
            --light-bg: #ecf0f1;
            --white: #ffffff;
            --text-dark: #2c3e50;
            --text-light: #7f8c8d;
            --border-color: #bdc3c7;
            --code-bg: #2d2d2d;
            --code-text: #f8f8f2;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 6px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            background-color: var(--light-bg);
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: var(--white);
            border-radius: 10px;
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #6c3483, var(--secondary-color));
            color: var(--white);
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .module-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .info-badge {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .content-wrapper {
            display: flex;
            min-height: calc(100vh - 200px);
        }

        .sidebar {
            width: 280px;
            background-color: #f8f9fa;
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: calc(100vh - 200px);
        }

        .sidebar h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .nav-item {
            padding: 12px 15px;
            margin-bottom: 5px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background-color: rgba(142, 68, 173, 0.1);
            border-left-color: var(--secondary-color);
        }

        .nav-item.active {
            background-color: rgba(142, 68, 173, 0.15);
            border-left-color: var(--secondary-color);
            font-weight: 600;
        }

        .nav-item.completed::after {
            content: " ‚úì";
            color: var(--success-color);
            float: right;
        }

        .main-content {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
        }

        .section {
            display: none;
            animation: fadeIn 0.4s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--secondary-color);
        }

        h3 {
            color: var(--secondary-color);
            margin-top: 30px;
            margin-bottom: 15px;
        }

        h4 {
            color: var(--primary-color);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        .definition-box {
            background-color: #f6f0fa;
            border-left: 4px solid var(--secondary-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .definition-box h4 {
            color: var(--secondary-color);
            margin-top: 0;
        }

        .example-box {
            background-color: #f0f7ff;
            border-left: 4px solid var(--info-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .example-box h4 {
            color: var(--info-color);
            margin-top: 0;
        }

        .warning-box {
            background-color: #fff3cd;
            border-left: 4px solid var(--warning-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box h4 {
            color: var(--warning-color);
            margin-top: 0;
        }

        .tip-box {
            background-color: #d4edda;
            border-left: 4px solid var(--success-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .tip-box h4 {
            color: var(--success-color);
            margin-top: 0;
        }

        .security-box {
            background-color: #f8d7da;
            border-left: 4px solid var(--accent-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .security-box h4 {
            color: var(--accent-color);
            margin-top: 0;
        }

        .code-block {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Courier New', monospace; /* Default to PowerShell for this module */
            font-size: 0.9em;
            line-height: 1.5;
            position: relative;
        }

        .code-block[data-lang="bash"]::before {
            content: "bash";
            color: var(--text-light);
        }

        .code-block[data-lang="powershell"]::before {
            content: "PowerShell";
            color: #5c9fd8;
        }

        .code-block::before {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 0.7em;
            text-transform: uppercase;
            font-weight: bold;
        }

        .inline-code {
            background-color: #f4f4f4;
            color: #c7254e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            font-weight: 600;
        }

        .command-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: var(--shadow);
        }

        .command-table th {
            background-color: var(--secondary-color);
            color: var(--white);
            padding: 12px;
            text-align: left;
        }

        .command-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .command-table tr:hover {
            background-color: var(--light-bg);
        }

        .interactive-exercise {
            background-color: var(--white);
            border: 2px solid var(--secondary-color);
            border-radius: 8px;
            padding: 25px;
            margin: 30px 0;
        }

        .interactive-exercise h3 {
            color: var(--secondary-color);
            margin-top: 0;
        }

        .exercise-question {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }

        .exercise-options {
            margin: 15px 0;
        }

        .exercise-option {
            display: block;
            padding: 12px;
            margin: 8px 0;
            background-color: var(--white);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .exercise-option:hover {
            border-color: var(--secondary-color);
            background-color: #f6f0fa;
        }

        .exercise-option input[type="radio"] {
            margin-right: 10px;
        }

        .check-answer-btn {
            background-color: var(--secondary-color);
            color: var(--white);
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .check-answer-btn:hover {
            background-color: #6c3483;
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            display: none;
        }

        .feedback.correct {
            background-color: #d4edda;
            border: 1px solid var(--success-color);
            color: #155724;
            display: block;
        }

        .feedback.incorrect {
            background-color: #f8d7da;
            border: 1px solid var(--accent-color);
            color: #721c24;
            display: block;
        }

        .progress-container {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .progress-bar-wrapper {
            background-color: var(--light-bg);
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-bar {
            background: linear-gradient(90deg, #6c3483, var(--secondary-color));
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-weight: bold;
            font-size: 0.9em;
        }

        .script-output {
            background-color: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            white-space: pre;
        }

        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-card {
            background-color: var(--white);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
        }

        .comparison-card h4 {
            color: var(--secondary-color);
            margin-top: 0;
        }

        .key-takeaways {
            background: linear-gradient(135deg, #6c3483 0%, var(--secondary-color) 100%);
            color: var(--white);
            padding: 30px;
            border-radius: 8px;
            margin: 30px 0;
        }

        .key-takeaways h3 {
            color: var(--white);
            margin-top: 0;
        }

        .try-it-yourself {
            background-color: #fff9e6;
            border: 2px dashed var(--warning-color);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .try-it-yourself h4 {
            color: var(--warning-color);
            margin-top: 0;
        }

        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid var(--border-color);
        }

        .nav-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .nav-btn.prev {
            background-color: var(--text-light);
            color: var(--white);
        }

        .nav-btn.next {
            background-color: var(--secondary-color);
            color: var(--white);
        }

        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        footer {
            background-color: var(--primary-color);
            color: var(--white);
            text-align: center;
            padding: 20px;
        }

        @media print {
            .sidebar, .navigation-buttons, .interactive-exercise {
                display: none;
            }
            .main-content {
                padding: 20px;
            }
            .section {
                display: block !important;
                page-break-after: always;
            }
        }

        @media (max-width: 968px) {
            .content-wrapper {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }
            .main-content {
                padding: 20px;
            }
            .comparison-table {
                grid-template-columns: 1fr;
            }
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .code-block pre,
        .script-output pre {
            margin: 0;
            padding: 0;
            white-space: pre;
            overflow-x: auto;
        }

        .code-block code,
        .script-output code {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: inherit;
            color: inherit;
            background: none;
            padding: 0;
            white-space: pre;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Module 5.7: Scripting Best Practices and Automation Strategies</h1>
            <div class="module-info">
                <div class="info-badge">üìö CSC 152 - Week 5</div>
                <div class="info-badge">‚è±Ô∏è 90 minutes</div>
                <div class="info-badge">üéØ CSLO 1, Objectives 7, 8, 9, 10</div>
                <div class="info-badge">üöÄ Automation Focus</div>
            </div>
        </header>

        <div class="content-wrapper">
            <aside class="sidebar">
                <h3>Module Contents</h3>
                <div class="nav-item active" onclick="showSection('intro')">Introduction</div>
                <div class="nav-item" onclick="showSection('general-best-practices')">General Best Practices</div>
                <div class="nav-item" onclick="showSection('bash-best-practices')">Bash Specific Practices</div>
                <div class="nav-item" onclick="showSection('powershell-best-practices')">PowerShell Specific Practices</div>
                <div class="nav-item" onclick="showSection('automation-strategies')">Automation Strategies</div>
                <div class="nav-item" onclick="showSection('version-control')">Version Control for Scripts</div>
                <div class="nav-item" onclick="showSection('integrated-example')">Integrated Automation Example</div>
                <div class="nav-item" onclick="showSection('summary')">Summary & Week 5 Review</div>

                <div class="progress-container" style="margin-top: 30px;">
                    <h3>Your Progress</h3>
                    <div class="progress-bar-wrapper">
                        <div class="progress-bar" id="moduleProgress">0%</div>
                    </div>
                    <p style="text-align: center; color: var(--text-light); font-size: 0.9em;">
                        <span id="sectionsCompleted">0</span> of 8 sections completed
                    </p>
                </div>
            </aside>

            <main class="main-content">
                <!-- Introduction Section -->
                <section id="intro" class="section active">
                    <h2>Introduction: From Scripts to Automation Solutions</h2>
                    
                    <p>Welcome to Module 5.7, the final module for Week 5! Throughout this week, you've gained extensive knowledge of advanced Bash commands (Module 5.1), Bash scripting (Module 5.2), PowerShell fundamentals (Module 5.3), PowerShell scripting (Module 5.4), SSH (Module 5.5), and PowerShell Remoting (Module 5.6). This module brings it all together, focusing on how to apply best practices to write professional-grade scripts and develop effective automation strategies for both Linux and Windows environments.</p>

                    <p>The goal is to transition from simply writing commands in a file to designing robust, maintainable, and secure automation solutions that can significantly enhance your efficiency as a system administrator.</p>

                    <h3>Why Best Practices and Strategies Matter</h3>

                    <div class="comparison-table">
                        <div class="comparison-card">
                            <h4>"Quick & Dirty" Scripts</h4>
                            <ul>
                                <li>Hard to understand later</li>
                                <li>Prone to errors in production</li>
                                <li>Difficult to debug or modify</li>
                                <li>Inconsistent results</li>
                                <li>Security vulnerabilities</li>
                                <li>Not easily shareable or scalable</li>
                            </ul>
                        </div>

                        <div class="comparison-card">
                            <h4>Professional Automation Solutions</h4>
                            <ul>
                                <li>Clear, self-documenting code</li>
                                <li>Reliable and robust</li>
                                <li>Easy to maintain and extend</li>
                                <li>Consistent performance</li>
                                <li>Secure by design</li>
                                <li>Reusable, shareable, and scalable</li>
                            </ul>
                        </div>
                    </div>

                    <h3>Module Learning Objectives</h3>
                    <p>By the end of this module, you will be able to:</p>
                    <ul>
                        <li>Identify and apply general scripting best practices common to both Bash and PowerShell.</li>
                        <li>Implement language-specific best practices for Bash and PowerShell scripts.</li>
                        <li>Recognize and prioritize automation opportunities in server administration.</li>
                        <li>Design automation strategies that leverage both Linux and Windows tools.</li>
                        <li>Utilize version control systems for managing script development.</li>
                        <li>Debug and troubleshoot script errors effectively across platforms.</li>
                        <li>Apply security best practices for all remote command-line access.</li>
                    </ul>

                    <h3>Prerequisites</h3>
                    <p>Before beginning this module, you should have completed:</p>
                    <ul>
                        <li>Module 5.1: Advanced Bash Command-Line Administration</li>
                        <li>Module 5.2: Bash Scripting Fundamentals</li>
                        <li>Module 5.3: PowerShell Fundamentals and Cmdlets</li>
                        <li>Module 5.4: PowerShell Scripting</li>
                        <li>Module 5.5: SSH Configuration and Remote Access (Linux)</li>
                        <li>Module 5.6: PowerShell Remoting and Remote Management (Windows)</li>
                    </ul>

                    <div class="tip-box">
                        <h4>üí° The Administrator's Mindset</h4>
                        <p>A good administrator is always looking for ways to automate. If you find yourself doing a task more than once, consider writing a script. If you do it more than three times, it *must* be automated!</p>
                    </div>
                </section>

                <!-- General Scripting Best Practices Section -->
                <section id="general-best-practices" class="section">
                    <h2>General Scripting Best Practices (Bash & PowerShell)</h2>
                    
                    <p>While Bash and PowerShell have different syntaxes and philosophies, many core scripting best practices apply to both. These universal principles ensure your scripts are effective, reliable, and maintainable.</p>

                    <h3>1. Documentation and Readability</h3>

                    <div class="definition-box">
                        <h4>üìñ Document Your Code</h4>
                        <p>Well-documented code is easier to understand, debug, and maintain, even by yourself months later.</p>
                    </div>

                    <div class="example-box">
                        <h4>Best Practices for Documentation</h4>
                        <ul>
                            <li><strong>Script Header:</strong> Include metadata like purpose, author, date, version, and usage examples.
                                <div class="code-block" data-lang="bash"><pre><code>#!/bin/bash
# Script: backup_data.sh
# Author: Jane Doe
# Date: 2026-02-23
# Description: This script backs up critical data to a remote server.
# Usage: ./backup_data.sh /path/to/source /path/to/destination</code></pre></div>
                                <div class="code-block" data-lang="powershell"><pre><code><#
.SYNOPSIS
    Backs up specified directory to destination

.DESCRIPTION
    This script creates a compressed backup of a source directory
    to a destination location with timestamp.

.PARAMETER SourcePath
    The directory to backup (required)

.EXAMPLE
    .\Backup-Data.ps1 -SourcePath "C:\Data" -DestinationPath "D:\Backups"
#></code></pre></div>
                            </li>
                            <li><strong>Comments:</strong> Explain complex logic, assumptions, or non-obvious steps.
                                <div class="code-block" data-lang="bash"><pre><code># Check if the backup directory exists. If not, create it.
if [ ! -d "$BACKUP_DIR" ]; then
    mkdir -p "$BACKUP_DIR"
fi</code></pre></div>
                                <div class="code-block" data-lang="powershell"><pre><code># Check if the service is running. If not, attempt to start it.
if ($service.Status -ne "Running") {
    Write-Host "Service $($service.Name) is stopped. Starting..."
    Start-Service -Name $service.Name
}</code></pre></div>
                            </li>
                            <li><strong>Clear Variable Names:</strong> Use descriptive names, e.g., <span class="inline-code">$computerName</span> instead of <span class="inline-code">$cn</span>.</li>
                            <li><strong>Consistent Formatting:</strong> Use consistent indentation, spacing, and line breaks.</li>
                        </ul>
                        <div class="tip-box">
                            <h4>üí° Tip: Comment Your Code</h4>
                            <p>Explain what each section does. Document any complex logic. Include usage examples in the script header. Future you will thank present you!</p>
                        </div>
                    </div>

                    <h3>2. Robustness and Error Handling</h3>

                    <div class="definition-box">
                        <h4>üìñ Build Resilient Scripts</h4>
                        <p>Scripts should be able to handle unexpected situations gracefully, rather than crashing or producing incorrect results.</p>
                    </div>

                    <div class="example-box">
                        <h4>Best Practices for Robustness</h4>
                        <ul>
                            <li><strong>Input Validation:</strong> Always validate parameters and user input to prevent unexpected behavior.
                                <div class="code-block" data-lang="bash"><pre><code>if [ -z "$1" ]; then
    echo "Error: Missing source path."
    exit 1
fi</code></pre></div>
                                <div class="code-block" data-lang="powershell"><pre><code>param(
    [Parameter(Mandatory=$true)]
    [ValidateNotNullOrEmpty()]
    [string]$SourcePath
)</code></pre></div>
                            </li>
                            <li><strong>Check Exit Codes/Success Status:</strong> Don't assume commands succeed.
                                <div class="code-block" data-lang="bash"><pre><code>cp "$source" "$destination" || { echo "Error: Copy failed!"; exit 1; }</code></pre></div>
                                <div class="code-block" data-lang="powershell"><pre><code>try {
    Copy-Item -Path $Source -Destination $Destination -ErrorAction Stop
} catch {
    Write-Error "Failed to copy item: $($_.Exception.Message)"
    exit 1
}</code></pre></div>
                            </li>
                            <li><strong>Logging:</strong> Implement a consistent logging mechanism to record script actions, warnings, and errors.
                                <div class="code-block" data-lang="bash"><pre><code>log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a /var/log/myscript.log
}
log_message "INFO: Script started"</code></pre></div>
                                <div class="code-block" data-lang="powershell"><pre><code>function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp [$Level] $Message" | Out-File -FilePath $LogFile -Append
}
Write-Log "Script started" "INFO"</code></pre></div>
                            </li>
                            <li><strong>Modular Design (Functions):</strong> Break down complex tasks into smaller, reusable functions.
                                <div class="code-block" data-lang="bash"><pre><code>function check_disk_space() { ... }
function perform_backup() { ... }</code></pre></div>
                                <div class="code-block" data-lang="powershell"><pre><code>function Test-DiskSpace { ... }
function Invoke-Backup { ... }</code></pre></div>
                            </li>
                        </ul>
                    </div>

                    <h3>3. Security</h3>

                    <div class="definition-box">
                        <h4>üìñ Secure Your Automation</h4>
                        <p>Scripts often run with elevated privileges or handle sensitive data. Security must be a top priority.</p>
                    </div>

                    <div class="example-box">
                        <h4>Best Practices for Security</h4>
                        <ul>
                            <li><strong>Least Privilege:</strong> Run scripts with the minimum necessary permissions. Avoid running as root/Administrator unless absolutely required.</li>
                            <li><strong>Secure Credential Management:</strong>
                                <ul>
                                    <li><strong>Bash:</strong> Use SSH keys with passphrases and `ssh-agent`. Avoid storing passwords in scripts.</li>
                                    <li><strong>PowerShell:</strong> Use `Get-Credential` for interactive input, encrypted credential files, or Just Enough Administration (JEA) for production.</li>
                                </ul>
                            </li>
                            <li><strong>Input Sanitization:</strong> Be wary of user input, especially if it's used in commands or file paths, to prevent injection attacks.</li>
                            <li><strong>Restrict Execution:</strong>
                                <ul>
                                    <li><strong>Bash:</strong> Set strict file permissions (`chmod 700`).</li>
                                    <li><strong>PowerShell:</strong> Configure `ExecutionPolicy` (e.g., `RemoteSigned`).</li>
                                </ul>
                            </li>
                            <li><strong>Avoid Hardcoding Sensitive Data:</strong> Passwords, API keys, etc., should never be hardcoded.</li>
                        </ul>
                    </div>

                    <h3>4. Testing and Debugging</h3>

                    <div class="definition-box">
                        <h4>üìñ Test and Debug Systematically</h4>
                        <p>Thorough testing and effective debugging are crucial for creating reliable scripts.</p>
                    </div>

                    <div class="example-box">
                        <h4>Best Practices for Testing and Debugging</h4>
                        <ul>
                            <li><strong>Start Simple:</strong> Begin with basic scripts and gradually add complexity. Test each component before adding the next. Don't try to write the entire script at once. Build incrementally and test frequently.</li>
                            <li><strong>Test Thoroughly:</strong> Test with various inputs, including edge cases (empty strings, large numbers, non-existent files). Test both success and failure scenarios.
                                <div class="tip-box">
                                    <h4>üí° Tip: Test Thoroughly</h4>
                                    <p>Test with valid and invalid inputs. Test success and failure scenarios. Test edge cases (empty files, large files, special characters). Test on a non-production environment first!</p>
                                </div>
                            </li>
                            <li><strong>Verbose/Debug Output:</strong> Use built-in debugging tools to trace script execution.
                                <div class="code-block" data-lang="bash"><pre><code>set -x # Bash: print commands before execution</code></pre></div>
                                <div class="code-block" data-lang="powershell"><pre><code>Write-Verbose "Processing item: $item" # PowerShell: use with -Verbose</code></pre></div>
                            </li>
                            <li><strong>WhatIf / Confirm:</strong> For destructive operations, always support a "dry run" mode.
                                <div class="code-block" data-lang="powershell"><pre><code>Remove-Item -Path $file -WhatIf # PowerShell: preview deletion</code></pre></div>
                            </li>
                            <li><strong>Use a Test Environment:</strong> Always test scripts in a non-production environment (e.g., a VM) before deploying to live systems.</li>
                        </ul>
                    </div>
                </section>

                <!-- Bash Specific Practices Section -->
                <section id="bash-best-practices" class="section">
                    <h2>Bash Specific Best Practices</h2>
                    
                    <p>Beyond the general principles, Bash scripting has its own set of best practices that leverage its unique features and address common pitfalls.</p>

                    <h3>1. Shebang and Execution</h3>

                    <div class="example-box">
                        <h4>Shebang and Execution</h4>
                        <ul>
                            <li><strong>Portable Shebang:</strong> Use <span class="inline-code">#!/usr/bin/env bash</span> for maximum portability.
                                <div class="code-block" data-lang="bash"><pre><code>#!/usr/bin/env bash</code></pre></div>
                            </li>
                            <li><strong>Execute Permissions:</strong> Always make scripts executable with <span class="inline-code">chmod +x script.sh</span>.</li>
                            <li><strong>Explicit Invocation:</strong> Always use <span class="inline-code">./script.sh</span> or <span class="inline-code">bash script.sh</span>. Avoid just <span class="inline-code">script.sh</span> if not in PATH.</li>
                        </ul>
                    </div>

                    <h3>2. Robustness and Error Handling</h3>

                    <div class="example-box">
                        <h4>Robust Bash Scripting</h4>
                        <ul>
                            <li><strong>Set Options for Safety:</strong>
                                <ul>
                                    <li><span class="inline-code">set -e</span>: Exit immediately if a command exits with a non-zero status.</li>
                                    <li><span class="inline-code">set -u</span>: Treat unset variables as an error.</li>
                                    <li><span class="inline-code">set -o pipefail</span>: Return the exit status of the last command in the pipe that exited with a non-zero status.</li>
                                </ul>
                                <div class="code-block" data-lang="bash"><pre><code>#!/usr/bin/env bash
set -euxo pipefail # Combine all useful options

# Your script logic here</code></pre></div>
                            </li>
                            <li><strong>Quoting Variables:</strong> Always double-quote variables when they might contain spaces or special characters.
                                <div class="code-block" data-lang="bash"><pre><code>filename="my file with spaces.txt"
# BAD: rm $filename
rm "$filename" # GOOD</code></pre></div>
                            </li>
                            <li><strong>Numeric Comparisons:</strong> Use <span class="inline-code">-eq</span>, <span class="inline-code">-ne</span>, <span class="inline-code">-gt</span>, etc. inside <span class="inline-code">[ ]</span> or <span class="inline-code">[[ ]]</span> for numbers.</li>
                            <li><strong>Use <span class="inline-code">[[ ]]</span> for Advanced Tests:</strong> It handles globbing, regex, and logical operators more gracefully.
                                <div class="code-block" data-lang="bash"><pre><code>if [[ "$variable" =~ ^[0-9]+$ ]]; then
    echo "Variable is numeric"
fi</code></pre></div>
                            </li>
                        </ul>
                    </div>

                    <h3>3. Functions and Reusability</h3>

                    <div class="example-box">
                        <h4>Bash Functions</h4>
                        <ul>
                            <li><strong>Use Functions:</strong> Encapsulate reusable logic.
                                <div class="code-block" data-lang="bash"><pre><code>function log_message() {
    echo "[$(date)] $1"
}</code></pre></div>
                            </li>
                            <li><strong>Local Variables:</strong> Use `local` keyword inside functions to prevent global variable pollution.
                                <div class="code-block" data-lang="bash"><pre><code>function process_data() {
    local temp_file="/tmp/data.tmp"
    # ...
}</code></pre></div>
                            </li>
                            <li><strong>Return Status, Not Output:</strong> Functions should primarily use `return` for exit status (0 for success, non-zero for failure) and `echo` for data output to be captured.</li>
                        </ul>
                    </div>

                    <h3>4. Command Chaining and Pipelines</h3>

                    <div class="example-box">
                        <h4>Efficient Bash Pipelines</h4>
                        <ul>
                            <li><strong>Filter Early:</strong> Reduce data size as early as possible in a pipeline.</li>
                            <li><strong>Use `xargs`:</strong> For processing a list of items as arguments to another command.
                                <div class="code-block" data-lang="bash"><pre><code>find . -name "*.log" -print0 | xargs -0 rm # Safely delete files with spaces</code></pre></div>
                            </li>
                            <li><strong>Backticks vs. `$(...)`:</strong> Prefer `$(...)` for command substitution as it nests better.
                                <div class="code-block" data-lang="bash"><pre><code>current_dir=$(pwd) # GOOD
# current_dir=`pwd` # OLD</code></pre></div>
                            </li>
                        </ul>
                    </div>
                </section>

                <!-- PowerShell Specific Practices Section -->
                <section id="powershell-best-practices" class="section">
                    <h2>PowerShell Specific Best Practices</h2>
                    
                    <p>PowerShell's object-oriented nature and .NET foundation bring a different set of best practices, emphasizing consistency, discoverability, and strong typing.</p>

                    <h3>1. Cmdlet Naming and Structure</h3>

                    <div class="example-box">
                        <h4>PowerShell Naming Conventions</h4>
                        <ul>
                            <li><strong>Verb-Noun Naming:</strong> Follow the `Verb-Noun` convention for all functions and scripts to maintain consistency. Use `Get-Verb` to see approved verbs.
                                <div class="code-block" data-lang="powershell"><pre><code>function Get-MyCustomServiceStatus { # GOOD
# function myServiceStatus { # BAD
}</code></pre></div>
                            </li>
                            <li><strong>Approved Verbs:</strong> Use `Get-Verb` to find a suitable verb for your function's action.</li>
                        </ul>
                    </div>

                    <h3>2. Robustness and Error Handling</h3>

                    <div class="example-box">
                        <h4>Robust PowerShell Scripting</h4>
                        <ul>
                            <li><strong>`try/catch/finally`:</strong> Use these blocks for robust error handling, especially for terminating errors.
                                <div class="code-block" data-lang="powershell"><pre><code>try {
    Get-Service -Name "NonExistentService" -ErrorAction Stop
} catch {
    Write-Error "Service not found: $($_.Exception.Message)"
}</code></pre></div>
                            </li>
                            <li><strong>`$ErrorActionPreference` & `-ErrorAction`:</strong> Set `$ErrorActionPreference = "Stop"` at the beginning of scripts, or use `-ErrorAction Stop` on individual cmdlets, to convert non-terminating errors into terminating ones that `try/catch` can handle.</li>
                            <li><strong>Parameter Validation:</strong> Leverage parameter attributes for automatic input validation.
                                <div class="code-block" data-lang="powershell"><pre><code>param(
    [Parameter(Mandatory=$true)]
    [ValidateRange(1, 100)]
    [int]$Percentage
)</code></pre></div>
                            </li>
                            <li><strong>`Test-Path` for Existence Checks:</strong> Always test for file/directory existence before operating on them.</li>
                        </ul>
                    </div>

                    <h3>3. Functions and Script Modules</h3>

                    <div class="example-box">
                        <h4>PowerShell Functions and Modules</h4>
                        <ul>
                            <li><strong>Advanced Functions:</strong> Use `[CmdletBinding()]` to make functions behave like cmdlets, supporting common parameters (`-Verbose`, `-WhatIf`, `-Confirm`).
                                <div class="code-block" data-lang="powershell"><pre><code>function Get-ServiceStatus {
    [CmdletBinding()]
    param(...)
    # ...
}</code></pre></div>
                            </li>
                            <li><strong>Pipeline Support:</strong> Design functions to accept pipeline input (`ValueFromPipeline` parameter attribute).</li>
                            <li><strong>Return Objects, Not Text:</strong> Functions should output objects, allowing further processing in the pipeline. Avoid `Write-Host` for primary output.</li>
                            <li><strong>Local Variables:</strong> Use `local` keyword inside functions to prevent variable scope issues.</li>
                        </ul>
                    </div>

                    <h3>4. The PowerShell Pipeline and Objects</h3>

                    <div class="example-box">
                        <h4>Efficient PowerShell Pipelines</h4>
                        <ul>
                            <li><strong>Filter Left, Format Right:</strong> Filter data as early as possible in the pipeline (e.g., `Where-Object`) and use formatting cmdlets (`Format-Table`, `Format-List`) as the very last step.</li>
                            <li><strong>Leverage `Select-Object`:</strong> Select only the properties you need to reduce memory usage and improve readability. Use calculated properties for custom output.
                                <div class="code-block" data-lang="powershell"><pre><code>Get-Process | Select-Object ProcessName, Id, @{Name="MemoryMB";Expression={[math]::Round($_.WorkingSet/1MB,2)}}</code></pre></div>
                            </li>
                            <li><strong>`ForEach-Object` vs. `foreach` Loop:</strong> Use `ForEach-Object` for pipeline processing, and the `foreach` language construct for processing collections already in memory.</li>
                        </ul>
                    </div>

                    <h3>5. Security and Remote Management</h3>

                    <div class="example-box">
                        <h4>Secure PowerShell Remoting</h4>
                        <ul>
                            <li><strong>Execution Policy:</strong> Set `ExecutionPolicy` to `RemoteSigned` or stricter.</li>
                            <li><strong>`TrustedHosts`:</strong> Manage `TrustedHosts` carefully in workgroup environments.</li>
                            <li><strong>HTTPS for WinRM:</strong> Configure WinRM to use HTTPS (port 5986) with valid SSL certificates.</li>
                            <li><strong>`Invoke-Command` vs. `Enter-PSSession`:</strong> Use `Invoke-Command` for one-to-many automation, `Enter-PSSession` for interactive troubleshooting.</li>
                            <li><strong>JEA (Just Enough Administration):</strong> For production, implement JEA to enforce least privilege.</li>
                        </ul>
                    </div>
                </section>

                <!-- Automation Strategies Section -->
                <section id="automation-strategies" class="section">
                    <h2>Automation Strategies</h2>
                    
                    <p>Understanding *how* to script is only half the battle. The other half is knowing *what* to automate and *how* to integrate automation into your daily operations.</p>

                    <h3>1. Identifying Automation Opportunities</h3>

                    <div class="definition-box">
                        <h4>üìñ Where to Automate?</h4>
                        <p>Look for tasks that are:</p>
                        <ul>
                            <li><strong>Repetitive:</strong> Tasks you do over and over again.</li>
                            <li><strong>Time-consuming:</strong> Tasks that take a long time manually.</li>
                            <li><strong>Error-prone:</strong> Tasks where human error is common.</li>
                            <li><strong>Scheduled:</strong> Tasks that need to run at specific intervals.</li>
                            <li><strong>Scalable:</strong> Tasks that need to be performed across many servers.</li>
                            <li><strong>Compliance-related:</strong> Tasks that require consistent configuration or reporting.</li>
                        </ul>
                    </div>

                    <div class="example-box">
                        <h4>Common Automation Scenarios</h4>
                        <ul>
                            <li><strong>System Health Checks:</strong> Disk space, memory, CPU, service status (Bash/PowerShell).</li>
                            <li><strong>Automated Backups:</strong> Files, databases, configurations (Bash/PowerShell, SCP/SFTP).</li>
                            <li><strong>User/Group Management:</strong> Provisioning, de-provisioning, permissions (Bash/PowerShell, AD cmdlets).</li>
                            <li><strong>Log Analysis:</strong> Searching for errors, generating reports (Bash: `grep`, `awk`, `sed`; PowerShell: `Get-WinEvent`, `Where-Object`).</li>
                            <li><strong>Software Deployment/Configuration:</strong> Installing packages, updating settings (Bash: `apt`, `yum`; PowerShell: `Install-WindowsFeature`, DSC).</li>
                            <li><strong>Reporting:</strong> Generating inventory, compliance reports.</li>
                            <li><strong>Patch Management:</strong> Automating update checks and installations.</li>
                        </ul>
                    </div>

                    <h3>2. Choosing the Right Tool (Bash vs. PowerShell)</h3>

                    <div class="definition-box">
                        <h4>üìñ Tool Selection Criteria</h4>
                        <p>The choice between Bash and PowerShell (or other languages) depends on several factors:</p>
                        <ul>
                            <li><strong>Operating System:</strong> Linux for Bash, Windows for PowerShell.</li>
                            <li><strong>Target Environment:</strong> What OS are the servers you're managing running?</li>
                            <li><strong>Existing Skill Sets:</strong> What are you and your team most proficient in?</li>
                            <li><strong>Integration Needs:</strong>
                                <ul>
                                    <li>Bash excels at text processing and chaining simple utilities.</li>
                                    <li>PowerShell excels at object manipulation and deep integration with Windows services/APIs (.NET).</li>
                                </ul>
                            </li>
                            <li><strong>Cross-Platform PowerShell:</strong> Consider PowerShell Core for managing both Windows and Linux from a unified client.</li>
                        </ul>
                    </div>

                    <h3>3. Scheduling Automation</h3>

                    <div class="definition-box">
                        <h4>üìñ Scheduling Tools</h4>
                        <p>Once a script is written, it needs to be scheduled to run automatically.</p>
                    </div>

                    <div class="example-box">
                        <h4>Scheduling Examples</h4>
                        <ul>
                            <li><strong>Linux: Cron Jobs:</strong>
                                <div class="code-block" data-lang="bash"><pre><code># Edit user's crontab
crontab -e

# Run script every day at 3 AM
0 3 * * * /path/to/your_script.sh >> /var/log/your_script.log 2>&1</code></pre></div>
                            </li>
                            <li><strong>Windows: Task Scheduler:</strong>
                                <div class="code-block" data-lang="powershell"><pre><code># Create a scheduled task to run daily at 3 AM
$action = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument '-File "C:\Scripts\YourScript.ps1"'
$trigger = New-ScheduledTaskTrigger -Daily -At "3am"
Register-ScheduledTask -Action $action -Trigger $trigger -TaskName "Daily Health Check" -Description "Runs daily system health check script" -User "SYSTEM"</code></pre></div>
                            </li>
                        </ul>
                    </div>

                    <h3>4. Idempotency (Advanced Concept)</h3>

                    <div class="definition-box">
                        <h4>üìñ Idempotent Scripts</h4>
                        <p>An <strong>idempotent script</strong> is one that can be run multiple times without causing side effects beyond the initial run. If a script creates a directory, running it again should not error out or create a duplicate. This is crucial for configuration management and continuous deployment.</p>
                    </div>

                    <div class="example-box">
                        <h4>Idempotency Example</h4>
                        <div class="code-block" data-lang="bash"><pre><code># Bash: Idempotent directory creation
mkdir -p /path/to/my_directory # -p ensures no error if it exists</code></pre></div>
                        <div class="code-block" data-lang="powershell"><pre><code># PowerShell: Idempotent directory creation
if (-not (Test-Path "C:\MyData" -PathType Container)) {
    New-Item -Path "C:\MyData" -ItemType Directory | Out-Null
}
# Or simply: New-Item -Path "C:\MyData" -ItemType Directory -Force | Out-Null</code></pre></div>
                        <p>Idempotency simplifies automation by allowing you to re-apply configurations without worrying about breaking existing setups.</p>
                    </div>
                </section>

                <!-- Version Control Section -->
                <section id="version-control" class="section">
                    <h2>Version Control for Scripts</h2>
                    
                    <p>Managing your scripts with a version control system like Git is a non-negotiable best practice for any professional administrator or developer.</p>

                    <h3>Why Use Version Control?</h3>

                    <div class="definition-box">
                        <h4>üìñ Benefits of Git for Scripts</h4>
                        <ul>
                            <li><strong>History Tracking:</strong> See who changed what, when, and why.</li>
                            <li><strong>Collaboration:</strong> Work with others on scripts without overwriting changes.</li>
                            <li><strong>Rollback:</strong> Easily revert to previous working versions if a script breaks.</li>
                            <li><strong>Experimentation:</strong> Create branches to test new features safely.</li>
                            <li><strong>Backup:</strong> Your scripts are stored remotely (e.g., GitHub, GitLab, Azure DevOps).</li>
                            <li><strong>Documentation:</strong> Commit messages provide a chronological record of changes.</li>
                        </ul>
                    </div>

                    <h3>Basic Git Workflow for Scripts</h3>

                    <div class="example-box">
                        <h4>Typical Git Commands</h4>
                        <div class="code-block" data-lang="bash"><pre><code># 1. Initialize a new Git repository in your script directory
git init

# 2. Add your scripts to the staging area
git add my_script.sh
git add *.ps1

# 3. Commit your changes
git commit -m "Initial commit: Added daily health check script"

# 4. Connect to a remote repository (e.g., on GitHub)
git remote add origin https://github.com/yourusername/your-scripts.git

# 5. Push your changes to the remote repository
git push -u origin main

# --- Later, when you make changes ---

# 1. Make changes to your script(s)

# 2. Check status
git status

# 3. Add changed files
git add .

# 4. Commit with a descriptive message
git commit -m "Feature: Added memory usage check to health script"

# 5. Push to remote
git push

# --- To get updates from others ---
git pull</code></pre></div>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Git Best Practices for Scripts</h4>
                        <ul>
                            <li><strong>Frequent Commits:</strong> Commit small, logical changes often.</li>
                            <li><strong>Descriptive Commit Messages:</strong> Explain *what* was changed and *why*.</li>
                            <li><strong>Branching:</strong> Use branches for new features or bug fixes, then merge back to `main` or `master`.</li>
                            <li><strong>Ignore Sensitive Files:</strong> Use a `.gitignore` file to prevent sensitive data (e.g., credential files) from being committed.</li>
                        </ul>
                    </div>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: Version Control</h4>
                        <ol>
                            <li>Create a new directory for your Week 5 scripts.</li>
                            <li>Initialize a Git repository in that directory (`git init`).</li>
                            <li>Copy one of your Bash or PowerShell practice scripts into it.</li>
                            <li>Add the script to staging (`git add`).</li>
                            <li>Commit the script (`git commit`).</li>
                            <li>(Optional, if you have a GitHub/GitLab account): Create a new remote repository and push your script to it.</li>
                        </ol>
                    </div>
                </section>

                <!-- Integrated Automation Example Section -->
                <section id="integrated-example" class="section">
                    <h2>Integrated Automation Example: Cross-Platform Health Check</h2>
                    
                    <p>This example demonstrates how you can combine Bash, PowerShell, SSH, and PowerShell Remoting to create a single script that monitors both Linux and Windows servers.</p>

                    <h3>Scenario: Monitor Hybrid Environment</h3>
                    <p>You have a hybrid environment with a Linux web server and a Windows database server. You need a single script to check their health.</p>

                    <h3>Solution Approach</h3>
                    <ol>
                        <li><strong>Local Client:</strong> A PowerShell script will act as the orchestrator.</li>
                        <li><strong>Linux Server:</strong> Connect via SSH to execute Bash commands.</li>
                        <li><strong>Windows Server:</strong> Connect via PowerShell Remoting to execute PowerShell cmdlets.</li>
                        <li><strong>Output:</strong> Consolidate results into a single report.</li>
                    </ol>

                    <div class="example-box">
                        <h4>`Monitor-HybridHealth.ps1` (PowerShell Orchestrator Script)</h4>
                        <div class="code-block" data-lang="powershell"><pre><code><#
.SYNOPSIS
    Monitors health of both Linux and Windows servers.

.DESCRIPTION
    This script connects to a specified Linux server via SSH and a Windows server
    via PowerShell Remoting to gather health information.

.PARAMETER LinuxServer
    Hostname or IP address of the Linux server.

.PARAMETER WindowsServer
    Hostname or IP address of the Windows server.

.EXAMPLE
    .\Monitor-HybridHealth.ps1 -LinuxServer "linuxvm" -WindowsServer "winserv"
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [string]$LinuxServer,

    [Parameter(Mandatory=$true)]
    [string]$WindowsServer
)

# Configuration
$LinuxUser = "yourlinuxuser"
$WindowsUser = "yourwindowsuser" # Local admin on Windows server
$ReportFile = "C:\Temp\HybridHealthReport_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"

# --- Functions ---

function Get-LinuxHealth {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Hostname,
        [Parameter(Mandatory=$true)]
        [string]$Username
    )
    
    Write-Verbose "Connecting to Linux server $Hostname via SSH..."
    
    try {
        # Commands to run on Linux server via SSH
        $sshCommand = "uptime; df -h /; free -h; systemctl is-active ssh"
        
        # Using ssh.exe (requires OpenSSH client on Windows)
        $output = ssh "$Username@$Hostname" $sshCommand 2>&1
        
        if ($LASTEXITCODE -ne 0) {
            throw "SSH command failed on $Hostname. Output: $output"
        }
        
        Write-Verbose "Successfully gathered Linux health data."
        return $output
    }
    catch {
        Write-Error "Error getting Linux health for $Hostname: $($_.Exception.Message)"
        return "ERROR: $($_.Exception.Message)"
    }
}

function Get-WindowsHealth {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Hostname,
        [Parameter(Mandatory=$true)]
        [PSCredential]$Credential
    )
    
    Write-Verbose "Connecting to Windows server $Hostname via PowerShell Remoting..."
    
    try {
        # Script block to run on Windows server
        $scriptBlock = {
            $os = Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion
            $mem = Get-CimInstance Win32_OperatingSystem
            $disk = Get-PSDrive -PSProvider FileSystem | Where-Object {$_.Name -eq 'C'}
            $services = Get-Service | Where-Object {$_.Status -eq 'Running' -and $_.StartType -eq 'Automatic'}
            
            [PSCustomObject]@{
                ComputerName = $env:COMPUTERNAME
                OS = $os.WindowsProductName
                OSVersion = $os.WindowsVersion
                TotalMemoryGB = [math]::Round($mem.TotalVisibleMemorySize / 1MB, 2)
                FreeMemoryGB = [math]::Round($mem.FreePhysicalMemory / 1MB, 2)
                C_DriveUsedGB = [math]::Round($disk.Used / 1GB, 2)
                C_DriveFreeGB = [math]::Round($disk.Free / 1GB, 2)
                RunningServicesCount = $services.Count
            }
        }
        
        $output = Invoke-Command -ComputerName $Hostname -ScriptBlock $scriptBlock -Credential $Credential -ErrorAction Stop
        
        Write-Verbose "Successfully gathered Windows health data."
        return $output
    }
    catch {
        Write-Error "Error getting Windows health for $Hostname: $($_.Exception.Message)"
        return "ERROR: $($_.Exception.Message)"
    }
}

# --- Main Script Logic ---

try {
    Write-Host "--- Starting Hybrid Health Check ---" -ForegroundColor Cyan
    
    # Ensure report directory exists
    $reportDir = (Split-Path $ReportFile -Parent)
    if (-not (Test-Path $reportDir)) {
        New-Item -Path $reportDir -ItemType Directory -Force | Out-Null
    }
    
    # Get Windows credentials
    $windowsCred = Get-Credential -UserName $WindowsUser -Message "Enter credentials for $WindowsUser on $WindowsServer"
    
    # Get Linux Health
    Write-Host "`n--- Linux Server Health ($LinuxServer) ---" -ForegroundColor Yellow
    $linuxHealth = Get-LinuxHealth -Hostname $LinuxServer -Username $LinuxUser
    $linuxHealth | Out-File -FilePath $ReportFile -Append
    $linuxHealth
    
    # Get Windows Health
    Write-Host "`n--- Windows Server Health ($WindowsServer) ---" -ForegroundColor Blue
    $windowsHealth = Get-WindowsHealth -Hostname $WindowsServer -Credential $windowsCred
    $windowsHealth | Format-List | Out-File -FilePath $ReportFile -Append
    $windowsHealth | Format-List
    
    Write-Host "`n--- Hybrid Health Check Complete ---" -ForegroundColor Cyan
    Write-Host "Full report saved to: $ReportFile" -ForegroundColor Green
    
    exit 0
}
catch {
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    exit 1
}</code></pre></div>
                    </div>

                    <div class="try-it-yourself">
                        <h4>üî® Try It Yourself: Integrated Automation</h4>
                        <p>This is a more advanced exercise, but it integrates many concepts from Week 5:</p>
                        <ol>
                            <li>Ensure you have two VMs configured: one Linux (with SSH server) and one Windows Server (with WinRM enabled).</li>
                            <li>Ensure SSH key-based authentication is set up for your Linux user, and a local admin user exists on the Windows server.</li>
                            <li>Save the `Monitor-HybridHealth.ps1` script to your local Windows client.</li>
                            <li>Modify `$LinuxUser` and `$WindowsUser` variables to match your VM setup.</li>
                            <li>Execute the script from your local Windows PowerShell console:
                                <div class="code-block" data-lang="powershell"><pre><code>.\Monitor-HybridHealth.ps1 -LinuxServer "YourLinuxVM_IP_or_Hostname" -WindowsServer "YourWindowsVM_IP_or_Hostname" -Verbose</code></pre></div>
                            </li>
                            <li>Observe the output and the generated report file.</li>
                            <li>Experiment by stopping a service on one of the VMs and re-running the script.</li>
                        </ol>
                    </div>
                </section>

                <!-- Summary Section -->
                <section id="summary" class="section">
                    <h2>Module 5.7 Summary & Week 5 Review</h2>
                    
                    <p>Congratulations on completing Module 5.7 and all of Week 5! You've transitioned from basic command-line usage to understanding and applying professional scripting best practices and automation strategies across both Linux and Windows environments.</p>

                    <h3>Key Takeaways from Week 5</h3>

                    <div class="key-takeaways">
                        <h3>üéØ Week 5 Learning Objectives Met</h3>
                        <ul>
                            <li>‚úÖ Executed common administrative tasks using Bash commands in Linux environments (Module 5.1).</li>
                            <li>‚úÖ Executed common administrative tasks using PowerShell cmdlets in Windows environments (Module 5.3).</li>
                            <li>‚úÖ Created simple administrative scripts in both Bash and PowerShell (Modules 5.2, 5.4).</li>
                            <li>‚úÖ Understood and implemented variables, loops, and conditional logic in scripts (Modules 5.2, 5.4).</li>
                            <li>‚úÖ Connected to remote systems using SSH (Linux) and PowerShell Remoting (Windows) (Modules 5.5, 5.6).</li>
                            <li>‚úÖ Configured SSH servers and clients for secure remote access (Module 5.5).</li>
                            <li>‚úÖ Compared and contrasted Bash and PowerShell scripting approaches (Modules 5.2, 5.4, 5.7).</li>
                            <li>‚úÖ Automated routine administrative tasks through scripting (Modules 5.2, 5.4, 5.7).</li>
                            <li>‚úÖ Debugged and troubleshoot script errors (Modules 5.2, 5.4, 5.7).</li>
                            <li>‚úÖ Applied security best practices for remote command-line access (Modules 5.5, 5.6, 5.7).</li>
                        </ul>
                    </div>

                    <h3>Comprehensive Scripting Best Practices Review</h3>

                    <div class="comparison-table">
                        <div class="comparison-card">
                            <h4>General Best Practices</h4>
                            <ul>
                                <li><strong>Documentation:</strong> Header, comments, clear names.</li>
                                <li><strong>Robustness:</strong> Input validation, error handling, logging.</li>
                                <li><strong>Security:</strong> Least privilege, secure credentials, restricted execution.</li>
                                <li><strong>Maintainability:</strong> Modular design (functions), consistent style.</li>
                                <li><strong>Testing:</strong> Incremental, thorough, dry-run options.</li>
                            </ul>
                        </div>
                        <div class="comparison-card">
                            <h4>Bash Specifics</h4>
                            <ul>
                                <li>`#!/usr/bin/env bash` shebang.</li>
                                <li>`set -euxo pipefail` for safety.</li>
                                <li>Double-quote variables.</li>
                                <li>Use `local` in functions.</li>
                                <li>`return` for status, `echo` for data.</li>
                                <li>Prefer `$(...)` for command substitution.</li>
                            </ul>
                        </div>
                        <div class="comparison-card">
                            <h4>PowerShell Specifics</h4>
                            <ul>
                                <li>`Verb-Noun` naming for functions.</li>
                                <li>`[CmdletBinding()]` for advanced functions.</li>
                                <li>`try/catch` with `-ErrorAction Stop`.</li>
                                <li>Parameter validation attributes.</li>
                                <li>Return objects, not text.</li>
                                <li>Filter Left, Format Right.</li>
                            </ul>
                        </div>
                        <div class="comparison-card">
                            <h4>Automation Strategies</h4>
                            <ul>
                                <li>Identify repetitive, error-prone tasks.</li>
                                <li>Choose tool based on OS, skills, integration.</li>
                                <li>Schedule with Cron (Linux) or Task Scheduler (Windows).</li>
                                <li>Design for idempotency.</li>
                                <li>Use Version Control (Git).</li>
                            </ul>
                        </div>
                    </div>

                    <h3>Connection to Course Objectives</h3>

                    <div class="key-takeaways">
                        <h3 style="color: white;">üéì CSLO 1 Achieved in Week 5!</h3>
                        <p>This entire week directly supports <strong>CSLO 1: Manage and maintain servers, including operating system (OS) configuration, access control and virtualization.</strong></p>
                        <p>By mastering command-line administration and scripting in both Linux and Windows, you've gained critical skills for efficient, scalable, and secure server management.</p>
                    </div>

                    <h3>Next Steps: Week 6 Preview</h3>

                    <div class="tip-box">
                        <h4>üí° What's Coming Up Next!</h4>
                        <p>Week 6 will delve into **User and Group Administration** for both Linux and Windows Server environments. You'll learn to:</p>
                        <ul>
                            <li>Manage local user accounts and groups in Linux.</li>
                            <li>Manage local user accounts and groups in Windows Server.</li>
                            <li>Understand file permissions and ownership in detail.</li>
                            <li>Apply scripting skills to automate user and group management tasks.</li>
                            <li>Prepare for Active Directory (covered in Week 11).</li>
                        </ul>
                        <p>Your scripting skills from Week 5 will be directly applicable to automating user and group management tasks in Week 6 and beyond!</p>
                    </div>

                    <h3>Final Week 5 Assignments Reminder</h3>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è Don't Forget Your Week 5 Assignments!</h4>
                        <p>Complete all Week 5 assignments by Sunday, February 23, 2026, 11:59 PM:</p>
                        <ul>
                            <li><strong>Lab 5:</strong> Command-Line Administration & Scripting (Linux & Windows)</li>
                            <li><strong>Discussion 5:</strong> Comparing Bash and PowerShell Automation</li>
                            <li><strong>Quiz 5:</strong> Command-Line & Scripting Concepts</li>
                        </ul>
                        <p>Remember to apply the best practices learned in this module to your lab submissions!</p>
                        <p><strong>Tips for Success in Lab 5:</strong></p>
                        <ul>
                            <li>Verify all scripts work correctly.</li>
                            <li>Check all screenshots are clear and relevant.</li>
                            <li>Proofread documentation and comments.</li>
                            <li>Verify file naming conventions.</li>
                        </ul>
                    </div>

                    <div class="navigation-buttons">
                        <button class="nav-btn prev" onclick="showSection('integrated-example')">‚Üê Previous: Integrated Example</button>
                        <button class="nav-btn next" onclick="window.print()">üñ®Ô∏è Print Module</button>
                    </div>
                </section>
            </main>
        </div>

        <footer>
            <p><strong>CSC 152 - Network Operating Systems and Administration</strong></p>
            <p>Module 5.7: Scripting Best Practices and Automation Strategies</p>
            <p style="margin-top: 10px;">Mendocino College | Computer Science Department</p>
            <p style="margin-top: 5px; font-size: 0.9em;">¬© 2026 | Version 1.0 | For Educational Use</p>
        </footer>
    </div>

    <script>
        const sections = ['intro', 'general-best-practices', 'bash-best-practices', 'powershell-best-practices', 'automation-strategies', 'version-control', 'integrated-example', 'summary'];
        let currentSectionIndex = 0;
        let completedSections = new Set();

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(sectionId).classList.add('active');
            
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (currentSectionIndex >= 0) {
                completedSections.add(sections[currentSectionIndex]);
                updateProgress();
            }
            
            currentSectionIndex = sections.indexOf(sectionId);
            window.scrollTo(0, 0);
        }

        function updateProgress() {
            const total = sections.length;
            const completed = completedSections.size;
            const percentage = Math.round((completed / total) * 100);
            
            document.getElementById('moduleProgress').style.width = percentage + '%';
            document.getElementById('moduleProgress').textContent = percentage + '%';
            document.getElementById('sectionsCompleted').textContent = completed;
            
            document.querySelectorAll('.nav-item').forEach((item, index) => {
                if (completedSections.has(sections[index])) {
                    item.classList.add('completed');
                }
            });
        }

        function checkAnswer(questionName, correctAnswer, feedbackId) {
            const selected = document.querySelector(`input[name="${questionName}"]:checked`);
            const feedback = document.getElementById(feedbackId);
            
            if (!selected) {
                feedback.className = 'feedback incorrect';
                feedback.textContent = '‚ö†Ô∏è Please select an answer.';
                return;
            }
            
            if (selected.value === correctAnswer) {
                feedback.className = 'feedback correct';
                feedback.textContent = '‚úÖ Correct! ' + getExplanation(questionName);
            } else {
                feedback.className = 'feedback incorrect';
                feedback.textContent = '‚ùå Incorrect. ' + getExplanation(questionName);
            }
        }

        function getExplanation(questionName) {
            const explanations = {
                'q1': 'An idempotent script is one that can be run multiple times without causing side effects beyond the initial run. This is a key principle in configuration management.',
                'q2': 'Git is a distributed version control system that allows you to track changes, collaborate, and revert to previous versions of your scripts. It is essential for professional script management.'
            };
            return explanations[questionName] || '';
        }

        document.addEventListener('DOMContentLoaded', updateProgress);
    </script>
</body>
</html>
